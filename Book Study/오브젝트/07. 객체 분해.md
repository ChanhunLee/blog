## 07. 객체 분해

- 인지과부하(cognitive overload)를 방지하는 수단
    - 추상화 : 불필요한 정보를 제거하고 핵심만 남기는 작업
    - 분해(decomposition) : 큰 문제를 해결 가능한 작은 문제로 나누는 작업

### 01 프로시저 추상화와 데이터 추상화
- 모든 프로그래밍 패더라임은 추상화와 분해의 관점에서 설명할 수 있다. 
- 추상화 메커니즘
    - 프로시저 추상화 : 무엇을 해야하는지를 추상화
        - 기능분해, 알고리즘 분해
    - 데이터 추상화 : 무엇을 알아야 하는지를 추상화
        - 타입추상화 : 추상 데이터 타입
        - 프로시저를 추상화 : 객체 지향

### 02 프로시저 추상화와 기능 분해
- 메인 함수로서의 시스템
    - 기능 분해의 관점에서 추상화의 단위는 프로시저.
    - 프로시저 추상화 : 로직을 재사용하고 중복을 방지할 수 있는 추상화방법
    - 프로시저 중심의 기능분해 관점에서 수학의 함수와 동일하다. 
    - 전통적으로 `하향식 접근법(Top-Down Approach)`을 따른다
        - 가장 최상위(topmost)를 정의하고 좀더 작은 단계로 분해해 나가는 방법. 
- 급여 관리 시스템
    - 기능분해 방법을 이용. 하향식 접근법을 따름
    - > - 직원의 급여를 계산한다
      >    - 사용자로부터 소득세율을 입력받는다
      >      - "세율을 입력하세요:"라는 문장을 화면에 출력한다.
      >      - 키보드를 통해 세율을 입력받는다. 
      >    - 직원의 급여를 계산한다.
      >      - 전역 변수에 저장된 직원의 기본급 정보를 얻는다.
      >      - 급여를 계산한다.
      >    - 양식에 맞게 결과를 출력한다.
      >      - "이름: {직원명}, 급여: {계산된 금액}" 형식에 따라 출력 문자열을 생성한다. 
    - 기능 분해 방법에서는 기능을 중심으로 필요한 데이터를 결정한다. 
- 급여 관리 시스템 구현
    - 햐향식 기능 분해는 시스템을 최상위의 가장 추상적인 메인함수로 정의하고 구현 가능한 수준까지 세부적인 단계로 분해하는 방법이다. 
    - 메인 함수를 루트로 하는 `트리(tree)`로 표현할 수 있다. 
- 하향식 기능 분해의 문제점
    > - 시스템은 하나의 메인 함수로 구성돼 있지 않다
    > - 기능 추가나 요구사항 변경으로 메인 함수를 빈번하게 수정해야 한다.
    > - 비지니스 로직이 사용자 인터페이와 강하게 결합된다. 
    > - 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.
    > - 데이터 형식이 변경될 경우 파급효과를 예측할 수 없다. 

    - 하나의 메인 함수라는 비현실적인 아이디어
        - 어느 시점에 이르면 유일한 메인 함수라는 개념은 의미가 없어지고 여러개의 동등한 함수 집합으로 성장하게 될 것이다. 
        - 하향식 접근법은 하나의 알고리즘이나 배치 처리에는 적합하지만 상호작용 시스템 개발에는 적합하지 않다.
        - 실제 시스템의 정상(top)이란 존재하지 않는다.
    - 메인 함수의 빈번한 재설계 
        - 기본급의 총합을 구하는 기능을 추가(sumOfBasePays)
            1. main함수의 로직을 새로운 calculatePay함수로 옮김
            2. sumOfBasePays 메소드 구성
            3. main에서 받은 인자로 두 작업중 어느것을 수행할지 지정하는 로직 추가 
        - 이 예제는 하나의 정상인 메인 함수에서 하향식 접근법의 기본 가정의 문제를 보여준다.
    - 비지니스 로직과 사용자 인터페이스의 결합
        - 하향식 접근법은 비지니스 로직 설계 초기 부터 입력 방법과 출력 양식을 함께 고민하도록 강요한다. 
        - 문제는 비지니스 로직과 사용자 인터페이스가 변경되는 빈도가 다르 다는것
        - 서로 변경에 영향을 받음
        - `관심사의 분리` 라는 아키텍쳐의 설계의 목적을 달성하기 어렵다. 
    - 성급하게 결정된 실행 순서 
        - 실행 순서나 조건, 반복과 같은 제어 구조를 미리 결정하지 않고는 분해를 진행할 수 없기 때문에 기능분해 방식은 중앙집중 제어 스타일의 형태를 띨 수밖에 없다. 
        - 문제는 함수의 제어 구조가 빈번한 변경의 대상이라는 점
        - 상위 함수가 강요하는 문맥안에서만 의미를 가지기 때문에 재사용이 어렵고 결합도가 높다.
    - 데이터 변경으로 인한 파급효과
        - 데이터를 어떤 함수가 사용하고 있는지 추적이 어렵다. 
        - 의존성과 결합도의 문제 
        - 데이터 변경 영향을 최소화 하려면 데이터와 함께 변경되는 부분과 그렇지 않은 부분을 명확하게 분리해야 한다. 
        - 기능 분해가 가진 문제를 해결하기 위해 정보은닉과 모듈이라는 개념을 제시
- 언제 하향식 분해가 유용한가?
    - 하향식은 이미 완전히 이해된 사실을 서술하기에 적합한 방법이다.
    - 그러나 새로운 것을 개발하고 설계하고, 발견하는 데는 적합한 방법이 아니다. 

### 03 모듈
- 정보 은닉과 모듈
    - 기능을 기반으로 시스템을 분해하는 것이 아니라 변경의 방향의 맞춰 시스템을 분해하는 것
    - 정보은닉 : 시스템을 모듈 단위로 분해하기 위한 기본 원리로 자주 변경되는 부분을 덜 변경되는 인터페이스 뒤로 감춰야 한다는 것이 핵심
    - 모듈은 서브 프로그램이라기보다는 책임의 할당이다. 
    - 모듈은 다음과 같은 두가지 비밀을 감춰야 한다.
        1. 복잡성 : 외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 모듈의 복잡도를 낮춘다. 
        2. 변경 가능성 : 변경 발생시 하나의 모듈만 수정되도록 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공한다. 
- 모듈의 장점과 한계 
    - 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다. 
    - 비지니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다. 
    - 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다. 

### 04 데이터 추상화와 추상 데이터 타입
- 추상 데이터 타입
    - 프로시저 추상화의 한계를 인지하고 보완하기 위해 데이터 추상화의 개념을 제안(바바라 리스코프)
    - 추상 데이터 타입 구현을 위해 다음과 같은 특성을 프로그래밍 언어가 지원해야함
        - 타입 정의를 선언할 수 있어야 한다.
        - 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다. 
        - 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다. 
        - 타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다. 
    - 추상 데이터 타입을 이용해 급여 관리 시스템을 개선해 보자
        - Employee 추상 데이터 타입 구현
            - 이름, 기본급, 직원여부, 작업시간을 내부 캡슐화 
            - 오퍼레이션 
                - calculatePay 구현
                - monthlyBasePay 구현
        - 추상 데이터 타입 Employee를 사용하는 직원들의 인스턴스 생성
        - sumOfBasePays 구현 : 정규 직원 전체에 대한 기본급 총합
    - 여전히 데이터와 기능을 분리해서 바라본다    
        - 표현된 데이터를 이용해서 기능을 구현하는 핵심로직은 추상 데이터 타입 외부에 존재한다. 
        - main 함수의 로직들이 바로 이 데이터를 사용하는 코드다 . 
    - 추상 데이터 타입은 데이터에 대한 관점을 설계 표면으로 끌어올리기는 하지만 여전히 데이터와 기능을 분리하는 절차적인 틀에 갇혀 있다. 


### 05 클래스
- 클래스는 추상 데이터 타입인가?
    - 대부분의 서적은 클래스를 추상 데이터 타입으로 설명하나 명확한 의미에서 추상 데이터 타입과 클래스는 동일하지 않다. 
        - 클래스는 상속과 다형성을 지원하는데 추상 데이터 타입은 못한다.
        - 이를 구분하기 위해 추상 데이터 타입 기반의 프로그래밍 패러다임을 객체기반 프로그래밍 이라고 부르기도 한다. 
    - 추상 데이터 타입은 타입을 추상화한 것 이고 클래스는 절차를 추상화한 것
    - 추상 데이터 타입의 Employee : 타입 추상화
        - 직원 타입을 캡슐화 하고 오퍼레이션이 모든 개념적인 타입에 대한 구현을 포괄
        - 급여계산 오퍼레이션에 직원과 아르바이트라는 두 직원 타입이 내부에 감춰져 있다.
    - 객체 지향 타입의 Employee : 절차 추상화 
        - 정규, 아르바이트 직원 각각에 대한 클래스를 정의
        - 각 클래스가 오퍼레이션을 적절히 구현한다. 
        - 공통 로직 위치에 대한 이슈
            - 부모클래스 상속
- 추상 데이터 타입에서 클래스로 변경하기 
    - Employee : 공통 속성과 메서드 시그니처만 정의 
    - SalariedEmployee : 정규직원, Employee상속
    - hourlyEmployee : 아르바이트, Employee상속
- 변경을 기준으로 선택하라 
    - 클래스가 추상 데이터 타입의 개념을 따르는지 확인하는 방법은 내부에 인스턴스 타입을 표현하는 변수가 있는지 확인하는 것.
        - 인스턴스 변수에 저장된 값을 기반으로 타입을 명시적으로 구분하는 방식은 객체지향 위반
    - 객체지향에서는 타입 변수를 이용한 조건문을 다형성으로 대체한다. 
        - 타입확인 후 적절한 메소드 호출하는 것이 아니라 객체가 메시지를 처리할 적절한 메서드를 선택
    - 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체 지향 특성을 `개방-폐쇄 원칙` 이라 한다. 
- 설계는 변경과 관련된 것이다
    - 설계의 유용성은 변경의 방향성과 발생빈도에 따라 결정
    - 타입 추가라는 변경의 압력이 더 강한 경우에는 객체지향
    - 오퍼레이션을 추가하는 것이 변경의 주된 압력이라면 추상 데이터 타입
- 협력이 중요하다
    - 객체지향에서 중요한 것은 역할, 책임, 협력이다.
    - 추상 데이터 타입과 클래스의 차이를 본것이지 객체를 설계하는 방법을 설명한 것은 아니다. 
        - 설계하는 방법은 3장의 책임 주도 설계의 흐름을 따른다는 점










