
영화 예매 시스템을 책임이 아닌 데이터 중심의 설계로 살펴보고 객체 지향적 설계와의 차이점을 확인해보자.

#### 데이터 중심의 영화 예매 시스템
- 데이터 중심의 관점은 상태에 초점을 맞추고 책임 중심의 관점은 행동에 초점을 맞춘다
- 훌륭한 객체 지향 설계는 데이터가 아니라 책임에 초점을 맞춰야 한다. 이유는 변경이 중요하기때문.

- 데이터를 준비하자
  - `데이터가 무엇인가` 를 묻는 것으로 시작해보자.
    - Movie에는 책임중심 설계때와는 다르게 `할인조건 목록` 과 `할인금액` `할인비율`을 직접 정의 하고 있다.
      - 할인 정책은 영화별로 하나만 지정가능하기에 할인금액과 할인비율은 하나의 값만 사용된다.
      - 영화에 설정된 할인 정책의 종류는 MovieType 열거형으로 결정된다.
    - 데이터 중심의 설계에서는 객체가 포함해야 하는 데이터에 집중한다.
    - 접근자와 수정자를 이용하여 캡슐화 한다.
    - 할인 조건을 설계한다 (DiscountCondition)
      - 할인 조건 타입 정의
      - 기본 정보 (순번, 요일, 시작/종료 시간)
    - Screening 클래스 구현
    - Reservation 클래스 구현
    - Customer 클래스 구현
  - 영화를 예매하자
    - ReservationAgency 클래스는 데이터 클래스들을 조합해서 예매 절차를 구현하는 클래스.
      - DiscountCondition에 대해 루프를 돌며 할인 가능 여부 체크
      - discountable 변수의 값을 체크하여 정책에 따라 요금 계산

#### 설계 트레이드오프
- 캡슐화
  - 변경될 가능성이 높은 부분을 `구현`, 상대적으로 안정적인 부분을 `인터페이스`라고 한다.
  - 객체지향에서 가장 중요한 원리는 `캡슐화`
  - 설계가 필요한 이유는 요구사항이 변경되기 때문이고, 캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제할 수 있기 때문.
- 응집도와 결합도
  - 응집도 : 모듈에 포함된 내부 요소들이 연관돼 있는 정도
  - 결합도 : 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도.
  - 변경의 관점에서의 응집도
  - 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도
- 변경의 관점에서의 결합도 
  - 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도
- 캡슐화를 지키면 모듈 안의 응집도는 높아지고 모듈 사이의 결합도는 낮아진다.

#### 데이터 중심의 영화 예매 시스템의 문제점
- 캡슐화 위반   
  - 접근자와 수정자 메서드는 어떤 정보도 캡슐화 하지 못한다. 
  - 접근자와 수정자에 과도하게 의존하는 설계방식을 추측에 의한 설계 전략(앨런 홀럽)
    - 객체가 사용될 협력을 고려하지 않고 다양한 상황에서 사용될 수 있을 것이라는 막연한 추측
- 높은 결합도 
  - 객체 내부의 구현이 객체의 인터페이스에 드러난다는 것은 클라이언트가 구현에 강하게 결합된다는 것을 의미
  - fee 타입을 변경한다고 하면 getFee, ResevationAgency 도 변경해야 한다.
    - getFee 메서드는 fee를 정상적으로 캡슐화 하지 못한것이다.
  - 결합도 측면에서 데이터 중심설계가 가지는 다른 단점은 제어로직이 특정 객체 안에 집중되어 다수의 데이터 객체에 강하게 결합된다는 것.
    - 제어객체 ReservationAgency가 모든 데이터 객체에 의존하게 된다. 
- 낮은 응집도
  - 서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존할 때 모듈의 응집도가 낮다고 한다. 
    - 변경과 상관없는 코드들이 영향을 받게 된다. 
    - 하나의 요구사항 변경을 반영하기 위해 여러 모듈을 수정해야 한다. 
  
#### 자율적인 객체를 향해
- 캡슐화를 지켜라
  - 객체는 스스로의 상태를 책임져야 하며 외부에서는 인터페이스에 정의된 메소드를 통해서만 상태에 접근 할 수 있어야 한다.
  - 객체에게 의미있는 메소드는 객체가 책임져야 하는 무언가를 수행하는 메소드이다. 
    - private라도 접근자와 수정자를 통해 속성을 외부로 제공하고 있다면 캡슐화를 위반하는 것.
- 스스로 자신의 데이터를 책임지는 객체
  - 객체를 설계할 때 데이터에 대한 2가지 질문
    - 이 객체가 어떤 데이터를 포함해야 하는가?
    - 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?
  - ReservationAgency에 있는 책임을 실제 데이터를 포함호고 있는 개체로 옮겨보자
    - DiscountCondition
      - 두개의 IsDiscountable 메소드 정의 : 할인조건 판단
      - IsDiscountable에서 할인type값을 이용해 현재의 타입에 맞는 적절한 메소드가 호출되었는지 판다
    - Movie
      - 요금계산 오퍼레이션
        - GetMovieType 메소드 정의
        - 할인 정책별 요금계산하는 세가지 메소드 정의
      - 할인여부 판단 오퍼레이션
        - IsDiscountable 메소드 정의
          - DiscountConditions에 포함된 DiscountCondition.IsDiscountable들을 확인해서 할인조건을 체크
    - Screening
      - CalclulateFee, CalclulateNoneDiscountedFee 메소드로 영화요금 계산
        - Movie의 isDiscountable메소드를 호출해 할인여부 판단 후 적절한 Movie 메소드를 호출해서 요금 계산
    - ReservationAgency 
      - Screening.CalclulateFee 를 호출해 예매요금을 계산한 후 계산된 요금을 이용해 Reservation 계산
#### 하지만 여전히 부족하다
- 캡슐화 위반
  - DiscountCondition
    - IsDiscountable 메서드를 통해 객체 내부에 DayOfWeek 타입의 요일과 LocalTime 시간정보, Int 타입의 순번 정보를 포함하고 있음을 외부에 노출한다.
    - DiscountCondition의 속성을 변경한다면 IsDiscountable 파라미터와 해당 메소드를 사용하는 모든 클라이언트가 수정되게 된다.
    - 내부 변경이 외부로 퍼저나가는 파급효과(ripple effect)는 캡슐화가 부족하다는 증거
  - Movie도 마찬가지
- 높은 결합도
  - 캡슐화 위반으로 DiscountCondition와 Movie 사이의 결합도는 높다
  - DiscountCondition.IsDiscountable 가 변경된다면 그것을 호출하는 Movie도 변경되게 된다. 
- 낮은 응집도
  - 할인 조건의 종류를 변경하기 위해서는 DiscountCondition와 Movie, Screening을 함께 수정해야 한다
  - 하나의 변경을 수용하기 위해 코드의 여러 곳을 동시에 변경해야 한다는 것응 응집도가 낮다는 증거
  - 응집도가 낮은 이유는 캡슐화 위반이 원인.

#### 데이터 중심 설계의 문제점
  1. 데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
  2. 데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.
   
- 데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다. 
  - 설계 실패 이유
    1.  데이터 중심관점에서는 객체는 단순한 데이터의 집합으로 취급
    2.  데이터를 먼저 결정하고 처리 오퍼레이션을 나중에 결정하는 방식은 데이터에 관한 정보가 인터페이스에 노출되게 된다. 결과적으로 캡슐화에 실패
- 데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다. 
  - 객체의 구현이 이미 결정된 상태에서 다른 객체와의 협력 방법을 고민하기 때문에 구현된 객체의 인터페이스를 억지로 맞추게 된다.
  - 객체의 인터페이스에 구현이 노출되어 협력이 구현 세부사항에 종속되고 그에 따라 내부 변경이 있을 시 모두 영향 받게 된다. 





