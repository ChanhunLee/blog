## 10. 합성과 유연한 설계

- 합성은 전체를 표현하는 객체가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용 한다.
- 상속관계를 `is-a` 관계라고 부르고 합성은 `has-a` 관계라고 부른다.
- 합성은 구현에 의존하지 않고, 내부에 포함되는 객체의 구현이 아닌 퍼블릭 인터페이스에 의존한다. 
- 상속은 클래스 사이의 정적인 관계인 데 비해 합성은 객체 사이의 동적인 관계다. 
  - 합성은 실행시점에 동적으로 변경이 가능하다. 
- 상속과 합성은 재사용의 대상이 다르다.
  - 합성은 포함되는 객체의 퍼블릭 인터페이스를 재사용한다. 

### 01 상속을 합성으로 변경하기

- 상속의 세가지 문제
  - 불필요한 인터페이스 상속
  - 메서드 오버라이딩 오작용 문제
  - 부모 클래스와 자식 클래스의 동시 수정 문제

- 합성을 사용하면 상속이 초래하는 세가지 문제점을 해결할 수 있다. 
- 합성으로 바꾸는 방법은 자식 클래스의 선언된 상속 관계를 제거하고 부모클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언하면 된다. 

#### 불필요한 인터페이스 상속 문제 : java.util.Porperties와 java.util.Stack

- 상속관계를 제거하고 부모클래스를 자식 클래스의 인스턴스 변수로 포함 시킨다
- 내부 구현에 밀접하던 상속과 달리 부모클래스의 내부 구현을 알지 못하게 된다. 
- 불필요했던 부모 클래스의 오퍼레이션들이 포함되지 않는다.

#### 메서드 오버라이딩의 오작용 문제 : InstrumentedHashSet
- Set 인터페이스 구현 
- 내부에서 HashSet 인스턴스 합성
  - 포워딩 : 내부의 인스턴스에게 동일한 메서드 호출을 그대로 전달하는 것
  - 포워딩 메서드 : 포워딩을 위해 추가된 메서드

#### 부모 클래스와 자식 클래스의 동시 수정 문제 : PersonalPlayList
- 합성을 사용해도 PlayList와 PersonalPlayList를 함께 수정하는 문제는 해결되지 않는다. 
- 그래도 합성이 좋음
  - 향우에 PlayList 내부 구현을 변경하더라도 파급효과를 최대한 PersonalPlayList 내부로 캡슐화할 수 있기 때문

> 몽키 패치 -> 현재 실행 중인 환경에만 영향을 미치도록 지역적으로 코드를 수정하거나 확장하는 것을 가리킨다. (C#의 확장 메서드 같은것)


### 02 상속으로 인한 조합의 폭발적인 증가
- 하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 한다. 
- 단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 늘어날 수 있다. 

#### 기본 정책과 부가 정책 조합하기
- 부가 정책을 추가 하자
  - 기본 정책의 계산 결과에 적용된다.
  - 선택적으로 적용할 수 있다. 
  - 조합 가능하다. 
  - 부가 정책은 임의의 순서로 적용 가능하다. 

#### 상속을 이용해서 기본 정책 구현하기
- 10장 코드 가져옴

#### 기본 정책에 세금 정책 조합하기
- 가장 간단한 방법은 RegularPhone 클래스를 상속받은 TexableRegularPhone 클래스를 추가하는 것
  - calculateFee 오버라이딩 후 Super 호출을 통해 부모 클래스의 calculateFee 호출, 리턴받은 일반 요금에 세금 정책을 적요하는 방법
  - 원하는 결과를 쉽게 얻지만 결합도가 높아짐
- 결합도를 낮추는 방법은 자식 클래스가 부모 클래스의 메소드를 호출하지 않도록 부모 클래스에 추상 클래스를 제공하는 것
  - Phone 클래스에 추상메서드 afterCalculated 추가 : 전체요금 계산후 수행할 로직을 추가할 수 있는 기회를 제공
  - 자식 클래스들 모두 afterCalculated 구현 
    - 자식 클래스가 많은 경우 문제가 되고
    - 해당 메소드가 필요가 없는 클래스들도 동일한 내용을 구현하게 됨
  - 필요 없는 자식을 위해 Phone에서 기본 구현을 제공
> 훅 메서드 : 추상 메서드와 동일하게 자식 클래스에서 오버라이딩할 의도록 메서드를 추가했지만 편의를 위해 기본 구현을 제공하는 메서드
- TexableNightlyDiscountPhone, TexableRegularPhone 사이에 코드 중복이 발생함
- 대부분 객체지향 언어는 단일 상속만 지원하기 때문에 상속으로 인한 코드 중복을 해결하기가 쉽지 않다. 

#### 기본 정책에 기본 요금 할인 정책 조합하기
- 두 번째 부가 정책, 기본요금 할인 정책 추가
  - RegularPhone을 상속받아 RateDiscountableRegularPhone 클래스 추가 
- 심야 할인 요금과 기본 요금 할인 정책을 조합하고 싶다면
  - NightlyDiscountPhone을 상속받아 RateDiscountableNightlyDiscountPhone 클래스 추가 
- `어떤 클래스를 선택해 상속하느냐에 따라 조합이 달라진다`

#### 중복 코드의 덫에 걸리다
- 부가 정책은 자유롭게 조합 가능하고 순서도 임의로 결정할 수 있어야 한다. 
- 지금 까지의 상속방식을 사용한다면 불필요하게 많은 수의 새클래스를 추가해야 한다. 
- 새로운 정책을 추가 하게 된다면 추가해야 할 클래스는 계속 늘어나게 된다.
  - 클래스 폭발, 조합의 폭발 

### 03 합성 관계로 변경하기










