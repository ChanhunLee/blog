## 10. 상속과 코드 재사용

- 객체지향에서는 코드를 재사용하기 위해 `새로운` 코드를 추가한다. 
- 대표적인 기법인 `상속` 에 대해!
- 새로운 클래스 인스턴스 안에 기존 인스턴스를 포함시키는 `합성`

### 01 상속과 중복 코드 

#### DRY 원칙

- 중복 코드는 변경을 방해한다. 
    - 변경시 중복을 모두 찾아야 한다.
    - 찾아낸 중복을 일관되게 수정해야 한다. 
    - 중복된 코드들을 동일한 테스트 결과를 내는지 확인해야 한다.

- 중복 코드의 판단
    - 요구사항 변경시 두 코드를 함께 수정해야 한다면 중복
    - 모양이 유사하다는 것은 단지 중복의 징후

- DRY 원칙(Dont Repeat Yourself)
    - 모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을 만한 표현 양식을 가져야 한다. 

#### 중복과 변경

##### 중복 코드 살펴보기 
- 전화 요금 계산 애플리케이션 : 통화시간을 단위 시간단 요금으로 나눠주는 프로그램
    - Call 클래스 : 개별 통화 기간 저장
        - From 통화 시작 시간
        - To 통효 종료 시간
    - Phone 클래스 : Call 목록을 관리한다. 
        - Amount 단위요금 
        - Seconds 단위 시간
        - Calls 통화 목록
        - CalculateFee 요금 계산

- 심야 할인 요금제의 추가
    - 가장 빠른 방법은 Phone의 코드를 복사하여 NightlyDiscountPhone 을 만든 후 수정
    - RegularAmount 밤 10시 이전 통화요금
    - NightlyAmount 밤 10시 이후 통화요금

##### 중복 코드 수정하기
- 통화 요금에 부과할 세금 계산 추가 
    - Phone 클래스 수정 
        - TaxRate 세율 추가
        - CalculateFee 메서드 수정
    - NightlyDiscountPhone 클래스 수정
        - Phone과 동일하게 수정해야 한다.
    - 동일한 수정을 안하면 세금이 잘못 부과됨
- 중복 코드는 새로운 중복 코드를 부른다
- 중복 코드의 양이 많아질수록 버그는 증가하며 그에 비례해 코드 수정은 어려워진다. 

##### 타입 코드 사용하기 
- 중복 제거 방법중 하나는 클래스를 하나로 합치는 것
    - 요금제 타입 코드를 추가 하고 로직을 분기 시켜 합칠 수 있다. 
        - 하지만 타입 코드를 사용하는 클래스는 낮은 응집도와 높은 결합도를 발생

#### 상속을 이용해서 중복 코드 제거하기
- NightlyDiscountPhone가 Phone 클래스를 상속받게 만들면 코드 대부분을 재사용할 수 있다. 
    - CalculateFee를 override 하여 재정의
    - 재정의시 부모 클래스를 재사용하는 것을 고려 해야 한다. 
- 부모클래스를 사용하는 방식은 여러 가정을 필요로 하고 이것은 코드를 이해하고 어렵게 만들고 직관적이지도 않다. 
- 자식 클래스의 작성자가 부모 클래스의 구현 방법에 대한 정확한 지식을 가져야 한다는 것을 의미
- 상속은 결합도를 높인다. 

#### 강하게 결합된 Phone과 NightlyDiscountPhone
- 부모, 자식 클래스의 결합이 문제인 이유를 살펴보자
  - 오버라이딩 및 super 참조를 이용해 부모클래스의 메서드 호출
  - 기능을 변경할 때 부모클래스와 자식의 오버라이딩한 메서드 둘다 수정이 필요한 경우가 생김
  - 상속을 했어도 중복 코드가 생김
  
> 상속을 위한 경고 1
> - 자식 클래스의 메서드에서 super 참조를 이용해 부모클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다. 

### 02 취약한 기반 클래스 문제 
- 부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상

#### 불필요한 인터페이스 상속 문제
- 자바의 초기 버전에서의 잘못된 상속 사례
  - Java.util.Stack
    - Vector 을 상속하여 구현
    - 문제 : Stack의 규칙을 무너뜨릴 여지가 있는 Vector의 퍼블릭 인터페이스까지 상속
  - Java.util.Properties
    - Hashtable 을 상속하여 구현 (object 키와 값을 저장)
    - 문제 : 제네릭 도입전이라서 타입체크 방법이 없었다. 그래서 string만 저장할 수 있는 Properties에 object 저장 가능으로 인해 오류 발생
- 퍼블릭 인터페이스에 대한 고려 없이 단순히 코드 재사용을 위한 상속이 위험한 걸 보여줌

#### 메소드 오버라이딩의 오작용 문제 
- 잘못된 구현을 방지 하기 위해선 부모 클래스의 내부 로직에 대한 이해가 필수 
  - 부모 클래스의 수정에 따른 위험을 방지하기 위해 코드를 작성하다 보면 다시 중복 코드가 생성될 확률이 높다.
  - 조슈아 블로치는 상속을 원한다면 클래스를 설계하고 문서화 해야하며 그렇지 않을 경우는 상속 금지를 시켜야 한다고 주장
- 상속은 코드 재사용을 위해 캡슐화를 희생한다.
- 완벽한 캡슐화를 원한다면 코드 재사용을 포기하거나 상속 이외의 다른 방법을 사용해야 한다. 

#### 부모 클래스와 자식 클래스의 동시 수정 문제
- 음악 목록을 추가할 수 있는 플레이리스트 구현
  - Song 클래스 : `singer, title` 속성 구현
  - PlayList 클래스 : `List<song> tracks` 속성 `append` 메소드 구현
  - PersonalPlayList : PlayList 클래스를 상속받아 remove 추가 구현
- PlayList의 수정 -> 가수 별 노래의 제목도 관리가 추가 되어야함 `singers` 
  - append 메소드 수정 
  - PersonalPlayList.remove도 수정이 불가피 함
- 부모클래스의 메서드를 오버라이딩 하거나 불필요한 인터페이스 상속을 하지 않았어도 부모 수정시 자식도 수정해야 할 수도 있다는 걸 보여줌

> 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 동시에 변경하거나 둘 중 하나를 선택할 수밖에 없다. 

### 03 Phone 다시 살펴보기

#### 추상화에 의존하자
- 부모, 자식 모두 추상화에 의존하도록 수정해야 한다. 
- 코드 중복을 제거하기 위해 상속을 도입할 때 두가지 원착
  - 두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라. 추출을 통해 동일한 형태로 보이도록 만들 수 있다. 
  - 부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라. 

#### 차이를 메서드로 추출하라.
- `변하는 것으로부터 변하지 않는 것을 분리하라`
- `변하는 부분을 찾고 이를 캡슐화 하라`
- Phone과 NightlyDiscountPhone의 CalculateFee의 for문 안에 구현된 로직을 메서드로 추출 
  - => calculateCallFee 추출

#### 중복 코드를 부모 클래스로 올려라 
- 추상 부모 클래스 생성 : AbstractPhone
  -  Phone과 NightlyDiscountPhone의 공통 부분을 부모 클래스로 이동 => CalculateFee
  -  calls 속성을 부모클래스로 이동
  -  부모 클래스에 calculateCallFee 추상 메소드 선언 protected
- `위로 올리기` 전략은 실패했더라도 수정하기 쉬운 문제를 발생시킨다
- 현재 클래스를 구체 클래스에서 추상 클래스로 변경하려 한다면 작은 실수 한번으로도 구체적인 행동을 상위 클래스에 남겨 놓게 된다. 

#### 추상화가 핵심이다
- 공통 코드를 이동시킨 후에 각 클래스는 서로 다른 변경의 이유를 가진다는 것에 주목하라. 
  - AbstrctPhone은 전체 통화 목록을 계산하는 방법이 바뀔 경우
  - Phone은 일반 요금제의 통화 한 건을 계산하는 방식이 바뀔 경우
  - NightlyDiscountPhone은 심야 할인 요금제의 통화 한 것을 계산하는 방식이 바뀔 경우
  - `세 클래스는 각각 하나의 변경 이유만을 가지며 단일 책임 원칙을 준수하기에 응집도가 높다`
- 추상화를 찾아 내고 상속 계층 안에 클래스들이 그 추상화에 의존하도록 리펙토링 하라
- 차이점을 메서드로 추출하고 공통적인 부분은 부모 클래스로 이동 하라

#### 의도를 드러내는 이름 선택하기
- 리펙토링후 직관적으로 이름을 바꾸어라
  - Phone => RegularPhone
  - AbstractPhone => Phone

#### 세금 추가하기
- 세금을 부과하는 요구사항을 추가해 보자
  - 모든 요금제에 공통 => Phone을 수정하자
  - taxRate 추가 하고 calculateFee 메서드 수정
  - 부모, 자식 생성자에 taxRate 초기화 코드 추가 
- 인스턴스 변수 변경 없이 객체의 행동만 변경된다면 상속 계층의 각 클래스는 독립적으로 진화시킬 수 있다.
- 하지만 인스턴스 변수가 추가 되는 경우는 다르다 
  - 자식 클래스는 부모클래스에 추가된 인스턴스 변수를 초기화하는 로직이 추가 되어야 한다. 
  - `결과적으로 아무리 책임을 잘 분리하더라도 인스턴스 변수의 추가는 종종 상속 계층 전반에 걸친 변경을 유발한다`
  - `하지만 두 클래스에 동일한 세금 계산 코드를 중복시키는 것보다는 현명한 선택이다.`

- 상속으로 인한 클래스 사이의 결합을 피할 수 있는 방법은 없다.
- 우리가 원하는 것은 행동을 변경하기 위해 인스턴스 변수를 추가하더라도 상속계층 전체에 걸쳐 부작용이 퍼지지 않게 막는 것이다. 

### 04 차이에 의한 프로그래밍
- 기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법
- 목표는 중복 코드를 제거하고 코드를 재사용 하는 것
- 상속이 코드 재사용이라는 측면에서 매우 강력한 도구인 것은 사실이지만 잘못 사용한 경우에 돌아오는 피해 역시 크다
- 정말로 필요한 경우에만 상속을 사용하라.
- 더 좋은 방법은 바로 `합성`













