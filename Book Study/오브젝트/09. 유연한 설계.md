## 09. 유연한 설계

- 앞장의 내용이 반복된다는 느낌을 받을 수 있다. 

### 01 개방-폐쇄 원칙

- 소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다. 
  - 확장에 열려 있다 : 요구사항이 변경될 때 변경에 맞게 새로운 `동작`을 추가해서 기능을 확장할 수 있다. 
  - 수정에 대해 닫혀 있다 : 기존의 `코드`를 수정하지 않고도 동작을 추가하거나 변경할 수 있다. 

#### 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라.

- 영화 예매 시스템의 할인 정책을 의존성 관점에서 다시 살펴보자
  - 컴파일타임
    - Moive -> DiscountPolicy
  - 런타임
    - Moive -> AmountDiscountPolicy, PercentDiscountPolicy
- 할인 정책 설계는 이미 개방-폐쇄 원칙을 따르고 있다. 
  - 할인 정책을 추가해서 확장가능, 기존코드 수정 없음

#### 추상화가 핵심이다.

- 개방-폐쇠 원칙의 핵심은 `추상화에 의존하는 것`
- 개방-폐쇠 원칙 관점에서 생략되지 않고 남겨진 부분 : 공통점을 반영한 추상화의 결과물
    - 수정할 필요가 없어야 한다. 
    - 확장의 여지를 남긴다. 
- DiscountPolicy의 코드(코드에 오타?)
    - 할인 여부 판단해서 요금계산 : public Money calculateDiscountAmount
        - 변하지 않는 부분 
    - 할인된 요금 계산 : abstract protected Money getDiscountAmount
        - 변하는 부분 - 추상화로 생략된 부분
        - 생략된 부분을 구체화함으로써 할인 정책을 확장
- Movie의 코드
    - DiscountPolicy에 의존
        - DiscountPolicy는 변하지 않는 추상화
        - DiscountPolicy의 자식 클래스를 추가하더라도 영향이 없기에 수정에 대해 닫혀 있다. 
- 추상화를 했다고 모든 수정에 대해 닫혀있는 것은 아니다. 신중하게 결정하라.

### 02 생성 사용 분리

- 추상화를 했다고 내부에서 인스턴스를 생성해서는 안된다. 
    - 객체 생성에 대한 지식은 과도한 결합도를 초래하는 경향이 있다. 
- 문제는 객체 생성이 아니라 부적절한 곳에서 객체를 생성하는 것
- `생성과 사용을 분리`하면 유연하고 재사용 가능한 설계를 할 수 있다. 
    - 보편적인 방법 : 객체 생성 책임을 클라이언트로 옮기는 것
    - ex) Client가 DiscountPolicy 생성 후 Movie 에게 전달

#### FACTORY 추가하기 

- Client도 생성과 사용의 책임을 함께 지니고 있다. 
- 객체 생성과 관련된 책임만 전담하는 별도의 객체를 추가 = FACTORY
- Client는 사용과 관련된 책임만 진다. 

#### 순수한 가공물에게 책임 할당하기

- 정보 전문가 - 책임 할당의 기본 원칙
- FACTORY는 도메인이(정보가 없음) 아니다. 추가한 이유는 순수하게 기술적인 결정.
- 크레이그 라만의 시스템을 객체로 분해하는 2가지 방식
    - 표현적 분해 : 도메인과 소프트웨어 사이의 표현적 차이를 최소화하는 것을 목적으로 한다. 
        - 모든 책임을 도메인 객체에게 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 문제점에 봉착
    - 행위적 분해 
        - 순수한 가공물 : 책임을 할당하기 위해 창조되는 도메인과 무관한 인공적인 객체
        - 행동을 책임질 마땅한 도메인 개념이 존재하지 않는 다면 순수한 가공물을 추가하고 책임을 할당하라 
- 객체지향 애플리케이션의 대부분은 실제 도메인에서 발견할 수 없는 순순한 가공물로 가득 차 있다. 
- 도메인 추상화를 기반으로 로직을 설계하는 동시에 품질의 측면에서 균형을 맞추는 데 필요한 객체들을 창조하라.   
    - 먼저 도메인의 개념을 추상화를 이용해 구축하고 만족스럽지 못하다면 인공적인 객체를 창조 하라
    - 애플리케이션을 구축하는 것은 원하는 기능을 제공하기 위해서지 실세계 모방이 아니다. 

### 03 의존성 주입

- 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법
- 세가지 방법
    1. 생성자 주입
        - 장점 : 객체가 올바른 상태로 생성되는 필요한 의존성 명확하게 표현
        - 단점 : 런타임에 변경 불가 
    2. Setter 주입
        - 장점 : 런타임에 의존성 변경 가능
        - 단점 : 객체가 올바로 생성되기 위해 어떤 의존성이 필수적인지 명시적 표현 불가 
    3. 메서드 주입
        - 생성자 주입에 비해 한 두개의 메서드에서만 의존성이 사용된다면 더 나은 방법일 수 있다.  

#### 숨겨진 의존성은 나쁘다 
- SERVICE LOCATOR 패턴 
    - 일종의 저장소, 인스턴스를 등록하고 반환할 수 있는 메서드를 구현한 저장소
    - 장점 : 사용하는 코드로 부터 구체 클래스가 무엇인지 인스턴스를 어떻게 얻을지 몰라도 되게 해준다.
    - 단점 : 의존성을 감춘다는 것
        - 의존성을 숨길 경우 관련 문제는 런타임에 발견된다. 
        - 단위 테스트 작성도 어렵다.
            - Service Locator는 정적 변수를 사용해 모든 단위 테스트 케이스에 걸쳐 상태를 공유
            - 각 단위 테스트는 고립돼야 한다는 기본 원칙 위반
        - 의존성을 이해하기 위해 코드 내부구현을 이해할 것을 강요 하게 된다
        - 의존성 대상을 설정하는 시점과 의존성이 해결되는 시점을 멀러 떨어트려 코드를 이해하고 디버깅하기 어렵게 만든다. 
- 의존성 주입은 SERVICE LOCATOR 패턴의 단점들을 해결해 준다. (의존성 명시적 표현)
- 명시적인 의존성이 숨겨진 의존성보다 좋다!

### 04 의존성 역전 

#### 추상화와 의존성 역전
- 의존성 역전 원칙
	- 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다. 
        - 협력의 본질을 담고 있는 것이 상위 수준 : Movie
	- 추상화는 구체적인 상황에 의존해서는 안 된다. 구체적인 상황은 추상화에 의존해야 한다. 

#### 의존성 역전 원칙과 패키지
- 객체지향 프로그래밍 언어에서 어떤 구성 요소의 소유권을 결정하는 것은 모듈이다(C#-namespace)
- Movie는 DiscountPolicy(interface)에 의존하고 있다. 
    - 정상적인 컴파일을 위해 DiscountPolicy가 필요하다.
    - DiscountPolicy와 같은 패키지 안에 AmountDiscountPolicy, PercentDiscountPolicy가 포함 되어 있다. 
    - `패키지 안에 어떤 클래스가 수정되더라도 Movie 역시 재컴파일 된다.`
    - 불필요한 클래스를 같은 패키지에 두는 것은 전체 빌드 시간을 상승시킨다. 
- 재사용을 위해 Movie, DiscountPolicy는 하나의 패키지, 나머지는 별도의 패키지에 위치시켜 의존성 해결
    - 추상화를 별도의 독립적인 패키지가 아니라 클라이언트가 속한 패키지에 포함시키고 나머지는 별도의 패키지로 모은다. 
    - 마틴파울러는 이 기법을 SEPARATED INTERFACE 패턴이라 한다. 

- `추상화가 제공하는 인터페이스의 소유권 역시 역전 시켜야 한다.`

### 05 유연성에 대한 조언

#### 유연한 설계는 유연성이 필요할 때만 옳다.
- 변경하기 쉽고 확장하기 쉬운구조를 위해서는 단순함과 명확함을 버리게 될 가능성이 높다. 
- 아직 일어나지 않은 변경은 변경이 아니다. 
- 유연성은 코드를 읽는 사람들이 복잡함을 수용할 수 있을 때만 가치가 있다. 

#### 협력과 책임이 중요하다. 
- 설계를 유연하게 만들기 위해선 협력에 참여하는 객체가 어떤 메시지를 전송하는지가 중요하다. 
- Movie가 다양한 할인 정책과 협력할 수 잇는 이유는 모든 정책이 calculateDiscountAmount 메시지를 이해할 수 있기 때문.
- 초보자의 실수 중 하나는 객체의 역할과 책임이 자리 잡기전 객체 생성에 집중하는 것
    - 책임을 할당하고 협력의 균형을 맞추는 것이 우선이다. 
- 불필요한 SINGLETON 패턴은 객체 생성에 관해 너무 이른 시기에 고민하고 결정할 때 도입되는 경향이 있다. 
    - 객체 생성은 모든 책임이 자리를 잡은 후 가장 마지막에 결정하는 것이 적절하다. 
- `역할 책임 협력` 에 `먼저` 집중하라





