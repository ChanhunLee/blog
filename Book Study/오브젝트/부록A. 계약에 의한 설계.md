## 부록 A. 계약에 의한 설계

- 인터페이스만으로는 객체의 행동에 관한 다양한 관점을 전달하기 어렵다. 
- 계약에 의한 설계를 사용하면 협력에 필요한 다양한 제약과 부수효과를 명시적으로 정의하고 문서화할 수 있다. 
- 이번장에서 중요한것은 코드가 아니라 `개념`

### 01 협력과 계약

#### 부수효과를 명시적으로 

- 프로그래밍 언어로 작성된 인터페이스는 객체가 수신할 수 있는 메시지는 정의할 수 있지만 객체 사이의 의사소통 방식은 명확하게 정의할 수 없다. 
  - 메시지의 이름과 파라미터 목록은 시그니처를 통해 전달하지만 협력을 위해 필요한 약속과 제약은 전달할 수 없기에 암시적인 상태로 남게 된다.

- 일정관리 프로그램을 이용해 계약에 의한 설계 개념 설명
  - Code Contract를 이용하여 IsSatisfied가 true 일때만 ReSchedule 메서드를 호출할 수 있다는 사실을 명확하게 표현
  - ``` c#
    Contract.Requires(IsSatisfied(schedule));
    ```
  - if문을 이용한 방식과 다르지 않을수 있지만 차이점이 더 크다
    - 문서화 

#### 계약

- 한쪽의 의무가 반대쪽의 권리가 된다. 
- 계약은 협력을 명확하게 정의하고 커뮤니케이션할 수 있는 범용적인 아이디어다. 


### 02 계약에 의한 설계

- 버트란드 마이어의 `계약에 의한 설계 기법`
  - 협력에 참여하는 각 객체는 계약으로부터 `이익`을 기대하고 이익을 얻기 위해 `의무`를 이행한다.
  - 협력에 참여하는 각 객체의 이익과 의무는 객체의 인터페이스 상에 문서화 된다. 

- 6장에서 설명한 `의도를 드러내는 인터페이스`를 만들면 시그니처만으로도 어느 정도까지는 클라이언트와 서버가 협력을 위해 수행해야 하는 제약조건을 명시할 수 있다. 

- 계약은 여기서 한걸음 더 나아간다.
- 계약에 의한 설계를 구성하는 세가지 요소
  - 사전조건 : 메서드가 호출되기 위해 만족돼야 하는 조건. 사전조건이 만족되지 않을 경우 메서드가 실행돼서는 안된다. 사전조건을 만족시키는 것은 메서드를 실행하는 클라이언트의 의무다. 
  - 사후조건 : 메서드가 실행된 후에 클라이언트에게 보장해야 하는 조건. 만약 클라이언트가 사전조건을 만족시켰는데도 사후조건을 만족시키지 못한 경우에는 클라이언트에게 예외를 던져야 한다. 사후조건을 만족시키는 것은 서버의 의무다. 
  - 불변식 : 항상 참이라고 보장되는 서버의 조건. 메서드가 실행되는 도중에는 불변식을 만족시키지 못할 수도 있지만 메서드를 실행하기 전이나 종료된 후에 불변식은 항상 참이여야 한다. 
  

#### 사전조건

- 일반적으로 사전조건은 메서드에 전달된 인자의 정합성을 체크하기 위해 사용된다. 
  - 예) 메서드 인자의 null 체크 또는 최소, 최대값 등
   ``` c#
   public Reservation Reserve(Customer customer, Int audienceCount)
   {
       Contract.Requires(customer != null);
       Contract.Requires(audienceCount >= 1);
       return new Reservation(customer, this, calculateFee(audienceCount), audienceCount);
   }
   ```
   - 사전 조건을 만족시킬 책임은 Reserve 메서드를 호출하는 클라이언트에게 있다는 사실을 기억하라. 
   - 다음과 같이 Reserve 메소드를 호출할 때 사전조건을 위반하면 ContractException이 발생한다
   ``` c#
   var reservation = screening.Reserve(null, 2);
   ```
   - 계약에 의한 설계의 장점
     - 계약만을 위해 준비된 전용 표기법을 사용해 계약을 명확하게 표현할 수 있다.
     - 일반 로직과 분리해서 서술함으로써 계약을 좀 더 두드러지게 강조할 수 있다.
     - 계약이 메서드의 일부로 실행되도록 함으로써 계약을 강제할 수 있다. 

#### 사후조건

- 사후조건은 메서드의 실행 결과가 올바른지를 검사하고 실행 후에 객체가 유효한 상태로 남아 있는지를 검증한다. 
- 클라이언트가 사전조건을 만족시켰는데도 서버가 사후조건을 만족시키지 못한다면 서버에 버그가 있음을 의미한다. 

- 일반적인 사후조건의 세가지 용도
  - 인스턴스 변수의 상태가 올바른지를 서술하기 위해
  - 메서드에 전달된 파라미터의 값이 올바른지를 서술하기 위해
  - 반환값이 올바른지를 서술하기 위해

- 두가지 이유로 인해 사전조건보다 사후조건을 정의하는 것이 더 어려울 수 있다.
  - 한 메서드 안에서 return 문이 여러 번 나올 경우
  - 실행 전과 실행 후의 값을 비교해야 하는 경우

#### 불변식

- 사전조건과 사후조건은 각 메서드마다 달라지는 데 반해 불변식은 인스턴스 생명주기 `전반에 걸쳐 지켜져야 하는 규칙`을 명세
- 일반적으로 불변식은 객체의 내부 상태와 관련이 있다. 
- 불변식의 두 가지 특성
  - 불변식은 클래스의 모든 인스턴스가 생성된 후에 만족돼야 한다. 이것은 클래스에 정의된 모든 생성자는 불변식을 준수해야 한다는 것을 의미한다.
  - 불변식은 클라이언트에 의해 호출 가능한 모든 메서드에 의해 준수돼야 한다. 메서드가 실행되는 중에는 객체의 상태가 불안정한 상태로 빠질 수 있기 때문에 불변식을 만족시킬 필요는 없지만 메서드 실행 전과 메서드 종료 후에는 항상 불변식을 만족하는 상태가 유지돼야 한다. 

- 불변식은 메서드가 실행되기 전에 사전조건과 함께, 실행된 후에는 사후조건과 함께 실행된다. 


### 03 계약에 의한 설계와 서브타이핑

- 계약에 의한 설계는 클라이언트가 만족시켜야 하는 사전조건과 클라이언트의 관점에서 서버가 만족시켜야 하는 사후조건을 기술한다. 
- 계약에 의한 설계와 리스코프 치환 원칙이 만나는 지점이 바로 이곳이다. 
- 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 계약을 준수해야 한다. 
  
- 리스코프 치환 원칙을 세분화한 두가지 규칙
  - 계약규칙
    - 서브타입에 더 강력한 사전조건을 정의할 수 없다. 
    - 서브타입에 더 완화된 사후조건을 정의할 수 없다. 
    - 슈퍼타입의 불변식은 서브타입에서도 반드시 유지돼야 한다. 
  - 가변성 규칙
    - 서브타입의 메서드 파라미터는 반공변성을 가져야 한다.
    - 서브타입의 리턴 타입은 공변성을 가져야 한다. 
    - 서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안 된다. 

- 계약에 의한 설계가 특정한 라이브러리나 프레임워크와는 상관이 없는 설계 개념이라는 사실을 강조하기 위한 예제를 살펴보자.

#### 계약 규칙

- 예제에 assert를 이용한 조건 추가

##### 서브타입에 더 강력한 사전조건을 정의할 수 없다. 

- 슈퍼타입에 정의된 사전조건을 강화하면 기존에 체결된 계약을 위반하게 된다.
- 강화한 서브타입은 클라이언트의 입장에서 수용이 불가능하기 때문에 슈퍼타입을 대체할 수 없게 된다.
- 따라서 서브타입의 사전조건 강화는 리스코프 치환 원칙 위반이다. 
- 반대로 서브타입의 사전조건 완화는 리스코프 치환 원칙을 위반하지 않는다.
  - 사전조건을 보장하는 책임은 클라이언트에게 있다. 

##### 서브타입에 더 완화된 사후조건을 정의할 수 없다. 

- 사후조건을 완화한다는 것은 서버가 클라이언트에게 제공하겠다고 보장한 계약을 충족시켜주지 못한다는 것을 의미
- 사후조건을 완하시키는 서버는 클라이언트의 괌점에서 수용할 수 없기 때문에 슈퍼타입을 대체할 수 없다. 
  - 리스코프 치환 원칙
- 반대로 사후조건 강화하는 경우는 계약에 영향을 미치지 않는다. 

##### 슈퍼타입의 불변식은 서브타입에서도 반드시 유지돼야 한다.

- 불변식은 메서드가 실행되 전과 후에 반드시 만족시켜야 하는 조건이다. 
- 자식 클래스가 계약위반 코드 작성을 막는법은 인스턴스 변수의 가시성을 protected가 아니라 private로 만드는 것 뿐이다.
- protected 변수를 가진 부모 클래스의 불변성은 자식클래스에 의해 언제라도 쉽게 무너질 수 있다
  - 자식에서 부모의 인스턴스 변수 상태를 변경하고 싶다면 protected 메서드를 제공하라. 
  - 해당 메서드에서 불변식을 체크하라.

#### 가변성 규칙

##### 서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안 된다. 

- 일반적으로 부모 클래스가 던지는 예외가 속한 상속 계층이 아닌 다른 상속 계층에 속하는 예외를 던질 경우 자식 클래스는 부모클래스를 대체할 수 없다. 
  - 따라서 서브타입이 아니다. 
- 부모클래스에 정의된 메소드를 자식클래스가 수행못하는 상황일때 예외를 던지느냐 아무것도 하지 않느냐의 차이는 있지만 클라이언트 입장에서는 자식클래스가 부모클래스보다 더 적은 일을 수행한다는 공통점이 있다. 
  - 부모클래스보다 못한 자식 클래스는 서브타입이 아니다. 
  
##### 서브타입의 리턴 타입은 공변성을 가져야 한다. 