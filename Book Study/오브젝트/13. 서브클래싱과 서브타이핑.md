## 13. 서브클래싱과 서브타이핑

- 상속의 두가지 용도
   - 타입 계층을 구현하는 것
       - 타입 계층 관점에서 부모 클래스는 자식 클래스의 `일반화` 이고 자식 클래스는 부모 클래스의 `특수화` 이다.
       - 코드 재사용
- 상속을 코드 재사용 목적으로 사용한다면 결합도를 높이지만 타입 계층을 목표로 사용하면 확장 가능하고 유연한 설계를 얻을 수 있다. 

### 01 타입

#### 개념 관점의 타입
- 개념 관점에서 타입이란 우리가 인지하는 세상의 사물의 종류를 의미/
- 어떤 대상이 타입으로 분류될 때 그 대상을 타입의 `인스턴스`라고 한다
- 일반적으로 타입의 인스턴스를 `객체` 라고 부른다. 
- 타입의 3가지 구성요소
    - 심볼 : 타입에 이름을 붙인 것. 앞에서 `프로그래밍 언어`가 타입의 심볼에 해당한다. 
    - 내연(intension): 타입의 정의로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동을 가리킨다. `프로그래밍 언어`의 정의인 `컴퓨터에게 특정한 작업을 지시하기 위한 어휘와 문법적 규칙의 집합`이 바로 내연에 속한다. 일반적으로 타입에 속하는 객체들이 공유하는 속성과 행동의 집합이 내연을 구성한다. 
    - 외연(extenstion) : 타입에 속하는 객체들의 집합이다. `프로그래밍 언어` 타입의 경우는 자바, 루비, JS, C가 속한 집합이 외연을 구성한다. 

#### 프로그래밍 언어 관점의 타입
- 비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙을 가리킨다.
- 프로그래밍 언어에서 타입의 두가지 목적
    - 타입에 수행될 수 있는 유요한 오퍼레이션의 집합을 정의한다.
    - 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다. 
- 적용 가능한 오퍼레이션의 종류와 의미를 정의함으로써 코드의 의미를 명확하게 전달 하고 개발자의 실수를 방지하기 위해 사용된다. 

#### 객체지향 패러다임 관점의 타입
- 타입을 두 가지 관점에서 정의할 수 있다.
    - 개념 관점에서 타입이란 공통의 특징을 공유하는 대상들의 분류
    - 프로그래밍 언어 관점에서 타입이란 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합
- 객체지향 프로그래밍에서 타입을 정의하는 것은 객체의 퍼블릭 인터페이스를 정의하는 것과 동일하다. 

> 객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다. 

### 02 타입 계층

#### 타입 사이의 포함관계 
- 타입들은 일반화와 특수화 관계를 가진 계층으로 표현할 수 있다. 
    - 타입 계층을 표현할 때는 더 일반적인 타입을 위쪽에, 더 특수한 타입을 아래쪽에 배치하는 것이 관례다. 
    - 더 일반적인 타입을 슈퍼타입, 더 특수한 타입을 서브타입 이라고 부른다. 
- `객체의 정의를 의미하는 내연`의 관점
    - 어떤 타입의 정의를 일반화란 보편적이고 추상적으로 만드는 과정
    - 반대로 특수화란 어떤 타입의 정의를 좀 더 구체적이고 문맥 종속적으로 만드는 과정.
- `집합을 의미하는 외연`의 과점
    - 일반적인 타입의 인스턴스 집합은 특수한 타입의 인스턴스 집합을 포합하는 `슈퍼셋`
    - 특수한 타입의 인스턴스 집합은 일반적인 타입의 인스턴스 집합에 포함된 `서브셋`
    - 따라서 특수한 타입에 속한 인스턴스는 동시에 더 일반적인 타입의 인스턴스 이기도 하다. 
> 일반화와 특수화의 정의
> 일반화는 다른 타입을 완전히 포함하거나 내포하는 타입을 식별하는 행위 또는 그 행위의 결과를 가리킨다.
> 특수화는 다른 타입 안에 전체적으로 포함되거나 완전히 내포되는 타입을 식별하는 행위 또는 그 행위의 결과를 가리킨다. 

- 슈퍼타입과 서브타입이라는 용어는 슈퍼셋과 서브셋으로 부터 유래한 것이다. 
> - 슈퍼타입은 다음과 같은 특징을 가지는 타입을 가리킨다. 
>    - 집합이 다른 집합의 모든 멤버를 포함한다.
>    - 타입 정의가 다른 타입보다 좀 더 일반적이다.
> - 서브타입은 다음과 같은 특징을 가지는 타입을 가리킨다.
>    - 집합에 포함되는 인스턴스 들이 더 큰 집합에 포함된다.
>    - 타입 정의가 다른 타입보다 좀 더 구체적인다. 

#### 객체지향 프로그래밍과 타입 계층
- 객체의 타입을 결정하는 것은 퍼블릭 인터페이스다.
- 퍼블릭 인터페이스 관점에서 슈퍼타입과 서브타입
    - 슈퍼타입 이란 서브타입이 정의한 퍼블릭 인터페이스를 일반화 시켜 상대적으로 범용적이고 넓은 의미로 정의한 것이다.
    - 서브타입 이란 슈터타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것이다. 

### 03서 서브클래싱과 서브타이핑

#### 언제 상속을 사용해야 하는가?
- 마틴 오더스키의 상속 사용에 대한 조건
  - 상속 관계가 is-a 관계를 모델링 하는가?
  - 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?

#### is-a 관계
- 어떤 타입 S가 다른 타입 T의 일종이라면 당연히 `타입 S는 타입 T다(S is-a T) 라고 말할수 있어야 한다. 
- 새와 펭귄의 예
  - 팽귄은 새다
  - 새는 날 수 있다. 
  - => 따라서 팽귄은 날 수 있다?
- 위 예는 어휘적인 정의가 아니라 `행동`에 따라 타입 계층을 구성해야 한다는 사실 보여준다. 
- 따라서 타입 계층의 의미는 행동이라는 문맥에 따라 달라질 수 있다.

#### 행동 호환성
- 타입의 이름 사이에 개념적으로 어떤 연관성이 있다고 하더라도 행동에 연관성이 없다면 is-a 관계를 사용하지 말아야 한다. 
- 두 타입 사이에 행동이 호환될 경우에만 타입 계층으로 묶어야 한다는 것이다.
  - 행동의 호환 여부를 판단하는 기준은 `클라이언트 관점`이라는 것이다. 
  - 클라이언트 입장에서 모든 새가 날 수 있다고 가정하기 때문에 단순히 is-a라고 표현할 수 있다고 해서 두 타입이 올바른 타입 계층을 구성한다고 말할 수 없다. 
- 상속 관계를 유지하면서 문제를 해결하기 위해 시도해 볼 수 있는 세가지 방법
  - fly 메서드를 오버라이딩 해서 내부 구조를 비워두는 것
    - 펭귄에 fly를 명령해도 아무 일도 일어나지 않는다. ->이것 역시 모든 새는 날 수 있다. 기대를 충족하지 못한다. 
  - 펭귄의 fly 메서드를 오버라이딩한 후 예외를 던지는 것
    - ->이것 역시 모든 새는 날 수 있다. 기대를 충족하지 못한다. 
  - flybird 메서드를 수정해서 인자로 전달된 bird의 타입이 펭귄이 아닐때만 fly메서드를 호출하는 것
    - ->이것 역시 모든 새는 날 수 있다. 기대를 충족하지 못한다. 

#### 클라이언트의 기대에 따라 계층 분리하기
- 날 수 있는 새와 날 수 없는 새를 구분할 수 있게 상속 계층을 분리
  - Bird
    - FlyingBird
    - Penguin
- 이제 FlyingBird 타입의 인스턴스만이 fly 메시지를 수신할 수 있다. 
- 다른 방법으로 문제 해결-> 클라이언트에 따라 인터페이스를 분리하는 것
  - interface flyer, interface walker
  - 펭귄은 walker 인터페이스만 구현
  - Bird는 flyer, walker 둘다 구현
- 만약 펭귄이 bird의 코드를 재사용 해야 한다면?
  - bird를 상속 받을순 있으나, fly가 펭귄에 추가 되기 때문에 이 방법은 사용할 수는 없다. 
  - `재사용을 위한 상속은 위험하다고 계속 이야기 함`
- 더 좋은 방법은 합성을 이용하는 것
  - 