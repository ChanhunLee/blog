## 1 스크럼을 소개 합니다. 

> 이 장의 주요 내용
> - 프로젝트의 주요 인원에게 역할 할당하기
> - 스크럼이 요구하고 생성하게 되는 여러 문서와 다른 산출물 구분하기
> - 전체 개발 진도에서 스크럼 프로젝트의 진척도 측정하기
> - 스크럼 프로젝트의 문제점을 분석하고 해결책 제시하기
> - 최고의 효율을 위해 효과적인 방향으로 스크럼 회의 주재하기
> - 애자일 및 다른 방법론들보다 스크럼을 채택하는 당위성 확보하기

- 스크럼 : 프로젝트 관리 방법론. 애자일 방법론은 하나. 반복적인 절차를 통해 소프트웨어 제품에 가치를 더하는 개념
- 스프린트 : 소프트웨어 개발이 완료될 때까지 반복되는 과정. 1주에서 4주간 진행되며 개발팀은 매일 일과를 통해 선별된 스토리를 구현해 나간다.
- 제품 백로그 : 구현되어야 할 기능과 스토리를 정의한다.
- 스프린트 백로그 : 스프린트 기간에 완료해야 할 작업들.
- 스토리 : 스크럼의 작업단위. 

### 스크럼 vs 폭포수

- 폭포수 방식의 문제점 
  - 너무 엄격하다. 한단계의 산출물이 다음 단계에 투입되고 다음단계로 이동하기 전에 반드시 완료되어야 한다. 
  - 한단계과 완료된 후에는 그에 대한 어떤 변경도 발생하지 않는다는 것을 전제로 한다. 
  - 요구사항의 정리와 디자인에 더 많은 시간을 할애하면 변화를 충분히 파악할 수 있다고 생각한다. (말이 되지 않는다.)

- 애자일의 변화에 대한 접근법
  - 변화를 받아 들이고 발생하면, 어느 누구라도 이를 수용할 수 있도록 허용한다. 
  
- 폭포수 방법론은 문서 중심적이기도 해서 많은 양의 문서를 만들어 내는 반면 애자일은 실제로 동작하는 소프트웨어 자체를 가장 중요한 문서로 여긴다. 
  - 어떤 코드는 문서화를 지원할 때 이점을 제공하기도 하지만, 아무도 읽지 않는 경우가 대부분이다. 이런 이유로 스크럼 팀은 대부분 위키처럼 라이브 문서 도구들을 활용한다. 

### 역할과 책임

#### 제품 소유자 Product Owner (PO)

- 제품 관리자 : 고객 또는 클라이언트와 나머지 개발팀을 연결하는 역할을 담당한다. 
- 제품 소유자 : 최종 제품에 대한 오너쉽을 가지며, 따라서 다음과 같은 책임도 수반하게 된다. 
  - 구현할 기능을 결정하는 책임
  - 비즈니스의 가치에 따라 기능의 우선순위를 결정하는 책임
  - 태스크의 완료 여부에 대한 판단을 내리는 책임

- PO는 프로젝트 성공의 핵심 이해관계자로 제품이 비전에 대해 명룡하게 커뮤니케이션 할 수 있어야 한다. 
- PO는 소프트웨어 릴리스에 포함되어야 하는 기능들과 제품 백로그 내의 우선순위를 결정해야 한다. 
  
- PO 역할이 아무리 중요하다고 해도 프로세스를 벗어난 영향력을 행사할 수는 없다. 
  - 개발팀의 작업 역량에 관한 것 (Commit 등)이나 작업 방법에 대하여 영향력을 행사할 수 없다. 
  - 스프린트 진행되는 동안에는 목표나 태스크 수렴 조건을 변경한다거나 스토리를 더하거나 빼는 등의 행위를 해서는 안된다. 
    - 진행이 시작된 스프린트는 변경이 불가능하다. 
    - 모든 변경 사항은 다음 스프린트까지 기다려야 한다.
    - 이렇게 함으로써 개발자는 흔들림 없이 목표에 집중할 수 있다. 

- 개발팀이 스토리를 처리하고 완료하면 검증을 요구하거나 진행 중인 태스크에 댓글을 작성할 수 있다. 
- 스프린트가 진행되는 동안 예상하지 못했던 상황이나 혼동이 발생했을 때는 PO가 개발팀과 의사소통을 위해 시간을 할애하는 것이 중요하다. 
  
#### 스크럼 마스터 Scrum Master(SM)

- 스프린트 기간에 외부의 간섭으로부터 팀을 보호하며, 팀이 스크럼을 통해 표시해 둔 방해 요소를 제거하는 역할을 담당한다. 
- 스크럼 마스터는 프로세스, 즉 결과물을 어떻게 만들 것인지와 관련된 프레임워크에 대한 오너십을 갖는다. 
  - 따라서 팀이 프로세스를 따르도록 만드는 것이 오롯이 스크럼 마스터의 책임이다. 
- 프로세스 개선을 위한 제안은 가능하지만 권한은 극히 제한적이라 프로세스를 따르는지를 확인하는 수준에서만 간섭할 수 있다. 
- 프로세스를 책임지는 사람으로서 매일 스크럼을 주재한다. 
  - 하지만 팀원들은 스크럼 마스터에게 업무보고를 하지 않고 모든 사람에게 내용을 공유한다. 

#### 개발팀

- 이상적인 상황이라면 애자일 팀은 `평준화된 전문가`들로 구성된다. 
  - 여러 다른 기술을 효율적으로 운영할 수 있으면서도 특정분야에 재능을 갖추고 있거나 특화된 전문가여야 한다는 말.
  - 팀이 다양한 기술을 갖춤으로써 애플리케이션 일부에 대한 지식을 한사람이 독점하는 상황을 방지할 수 있다.  
  - 한 가지 역할만을 강조하는 것은 프로젝트에 참여하는 모든 사람에게 좋지 않다. 
- `스크럼에서 코드는 팀 전체의 것이다.` 내가 할 수 있는 것에만 역할을 한정하면 편협한 사고에 빠질수 있다. 

- 소프트웨어 테스터는 품질을 관리하는 책임을 가진다. 스토리가 시작되기전 요구 사항을 만족하도록 구현되었는지를 검증하기 위해 테스트를 어떻게 자동화할 것인지를 논의한다.
- 스토리가 구현되면 개발자는 테스트를 요청하며, 테스트 전문가는 해당 기능이 요구대로 동작하는지를 검증한다. 

#### 돼지와 닭
- 스크럼 프로세스에서 각각의 역할은 돼지 혹은 닭으로 분류할 수 있다. 
- 헌신자 (committer)와 기여자(contributor)를 표현한다. 
  - 헌신자 : 프로젝트에 완전히 헌신하며 그 결과물에 대한 책임을 진다. (PO, 스크럼 마스터, 개발팀)
  - 기여자 : 프로젝트에 기여하며 보조적인 형태로 참여한다.

### 산출물

- 모든 애자일 프로세스와 다른 프로세스들의 가장 큰 차이점은 문서의 상대적 중요도이다. 
- 애자일 프로세스는 프로젝트의 성공을 위해 반드시 필요한 것을 제외하고는 문서의 양을 줄이는 것을 목표로 하고 있다.
  - 대신 코드로 문서를 대신하고 있다.
- 애자일 프로젝트에서도 문서는 중요하지만 실제로 동작하는 소프트웨어나 구성원 간의 의사소통보다 더 중요하게 여기지는 않는다. 

#### 스크럼 보드

- 스크럼 프로젝트의 일상을 관리하는 중심은 스크럼 보드이다. 
- 어떤 방법을 사용하든 스프린트를 두어 번 진행해 보면서 뭔가 올바르지 않다고 느껴진다면 얼마든지 변경해도 좋다. 
- 스크럼 보드는 정보의 보고이다.

##### 카드

- 스크럼 보드에서 가장 중요한 아이템은 카드이다. 
- 작은 태스크로부터 물리적인 소프트웨어의 릴리스에 이르기까지 제품의 진도를 나타내는 개별적인 요소를 표현한다. 

##### 구성의 계층구조

- 스크럼 보드 상의 카드들 사이의 상관 관계를 보여 준다. 
- 아무리 복잡한 소프트웨어라 하더라도 결국에는 유한한 수의 개별 태스크로 나눌 수 있으며, 하나씩 완료함으로써 완성해 나갈 수 있다. 

##### 제품

- 스크럼 먹이사슬의 최상위
- 팀은 주로 한 번에 한 제품을 대상으로 하지만 때로는 여러 개의 제품을 준비해야 할 때도 있다.

##### 릴리스

- 모든 제품은 여러번의 릴리스를 거칠 수 있다. 
- 릴리스는 최종 사용자가 구매하거나 서비스로서 사용하게 되는 소프트웨어 버전을 말한다. 
- 크롬과 IE의 예
  - IE는 8,9,10등 큰 업데이트가 있고 이를 광고도 하지만 크롬은 버전과 무관하게 브라우저 자체만을 광고한다
  - 크롬은 작은 크기의 릴리스들이 끊임없이 배포된다. 
- 스크럼은 매 스프린트가 끝날 때마다 문제없이 동작하는 소프트웨어를 출시할 수 있도록 하는 것에 집중함으로써 이런 릴리스 패턴을 이끌어 낼 수 있다. 

##### 기능

- 각 릴리스는 그전까지 제공되지 않던 하나 이상의 기능(feature)들로 구성된다
- 최소 시장성 기능(MMF, Minimum Maketable Feature)는 기능을 묘사하고 릴리스를 구성하는데 도움이 된다. 
- 기능은 각 릴리스마다 필수(required), 선호(preferred), 바람(desired)등 크게 세 가지로 분류될 수 있다.
  - 이들은 각 기능에 배정되는 우선순위를 반영하는 상호 배타적인 옵션이다. 
  - 주로 선호되는 기능 구현에 앞서 필수 기능을 먼저 구현하며 바람에 해당하는 기능은 시간적 여유가 있을 때만 구현한다. 
  - 분류는 언제든지 변경 가능하다. 
  - 스크럼에서는 무엇이든 변경될 수 있다.

##### 사용자 스토리

- 이는 스크럼에서 정의한 개념이 아니다.
- 익스트림 프로그래밍의 산출물이지만, 매우 대중적으로 사용되기 때문에 스크럼에서도 사용되는 것뿐이다.
- 사용자 스토리는 아래의 템플릿을 이용해 정의한다.
  - `[사용자의 역할]로서, 나는 [동사 위주의 행위]를 함으로써 [사용자에게 제공할 가치]를 얻고자 한다.`
  - 예) 등록은 완료했지만 아직 인증을 받지 않은 사용자로서, 나는 비밀번호 재설정을 통해 비밀번호를 잃어버린 상황에서도 시스템에 로그인할 수 있어야 한다. 

- 사용자 스토리에서 주목할 만한 점
  - 실제로 어떤 기능을 구현해야 하는지에 대한 충분한 상세 설명을 제공하지는 않는다는 점.
    - 사용자 관점에서 작성되어야 하는데 빈번하게 개발자 관점에서 작성되곤 한다. 
    - `사용자의 역할`로서가 중요하며 `사용자에게 제공할 가치` 부분 역시 중요하다
  
- 스토리 많으로는 개발을 시작하기에 충분하지 않다.
  - 스토리에 대해 충족되어야 할 요구 사항을 분석 기간을 통해 사용자로부터 도출한다. 
  - 그 후 요구 사항을 충족할 수 있는 디자인 아이디어들을 수집한다.
  - 디자인에 대한 승인을 얻으면 팀은 사용자 스토리를 작은 태스크로 분리한 후 이를 구현해 나가면서 스토리를 구현해 나간다. 
  - 마지막 단계인 QA 기간에는 수렴 가능한 조건들에 대한 동작을 점검하고 수용여부를 결정. 
  - 기능들이 수용되면 스토리는 완료된다.
  
- 이는 마치 폭포수와 동일한 것으로 보인다. 전체 소프트웨어 주기를 축소하여 각각의 스토리에 적용하는 것이다. 

##### 태스크

- 사용자 스토리보다 더 작은 작업 단위
- 사용자 스토리는 여러 개의 관리 가능한 태스크로 분리되어 스토리에 배정된 개발자들에게 할당된다. 
- 사용자 스토리는 특정 기능을 구현하기 위해 수직적으로 분할되어야 하지만, 태스크는 팀 내 개발자들의 특성을 활용할 수 있도록 계층 수준으로 분리될 수도 있다. 
- 사용자 스토리는 스토리 포인트를 가지고 있으며 이는 스토리를 구성하는 태스크들로 전이되지 않는다는 점을 인지해야 한다. 
  - 부분적으로 완료된 작업에는 어떤 인센티브나 보수도 없다. 
  - 완료되었다는 것을 QA를 통해 증명하지 못하면 스토리가 보유하고 있던 포인트는 전혀 적용되지 않는다. 
  - 스토리가 완료되기까지 너무 오래 기간이 소요된다면 애당초 너무 큰 작업이었으므로 스토리가 분리되었어야 한다는 것을 의미한다. 

##### 결함

- 결함을 표현하는 카드는 이미 완료된 사용자 스토리가 수렴 가능한 조건을 만족하지 못할 때마다 생성한다. 
- 이 카드는 자동화된 테스트 환경을 필요로 한다. 
- 기술 부채와 마찬가지로 결함 카드는 스토리 포인트를 가지지 않는다. 
- 결함은 크게 A(심각한 결함 apocalyptic defects), B(행위 오류, behavioral error), C(표현 이슈, cosmetic issue)로 분류할 수 있다. 
  - 심각한 결함 : 애플리케이션이 완전히 실패하거나 작업을 계속할 수 없는 결함, 높은 우선순위, 반드시 수정필요
  - 행위 오류 : 사용자의 짜증을 유발, 상황에 따라 심각할 수 있음, 중간 우선순위
  - 표현 이슈 : 주로 사용자 인터페이스 문제, 외관상의 문제, 낮은 우선순위
 
##### 스윔레인

- 개발 주기에 걸쳐 진행 중인 스토리의 상태를 표시하기 위해 구분하는 구역
- 기본적인 스윔레인은 백로그, 진행 중, QA 및 완료로 구성된다. 
  - 백로그 레인의 스토리는 특정 스프린트에 진행하는 것으로 `승인된` 것이여야 하며 스토리보드에서 떼어 내고 작업을 시작해야 한다. 
  - 백로그로 부터 떼어낸 티켓은 제품 소유자와 함께 기능의 범위와 요구 사항들에 대한 대화를 완료하면 산출 태스크들과 함께 진행 레인으로 돌아온다. 
  - 스토리를 위한 분석과 디자인, 그리고 구현이 모두 완료되면 `개발자 완료` 상태가 되어 품질 보증 스윔레인으로 옮겨갈 수 있는 상태가 된다. 
- 테스트 분석가는 수렴 가능한 조건들을 바탕으로 스토리를 평가한다.
  - 이상적인 경우의 QA 환경은 실제 서비스 환경을 최대한 반영하여 배포 시 발생할 수 있는 작은 차이점으로 인한 환경적 오류를 최소화할 수 있어야 한다.
- 모든 것이 완벽하게 완료되면 사용자 스토리는 완료 스윔레인으로 이동한다. 
- 스토리에 할당된 스토리 포인트를 획득하게 되고 스프린트 번다운 차트가 수정 된다. 

##### 수평 스윔레인

- 스크럼 보드는 수평 스윔레인을 통해 `구분될 수도` 있다. 
- 이 스윔레인을 통해 스토리를 기능 단위로 그룹화하여 모든 사람이 어느 지점에 팀의 역량이 집중되고 있는지, 나아가 어느 지점에 병목 현상이 발생하는지를 한눈에 파악할 수 있도록 한다. 

##### 기술 부채
- 사용자 스토리를 구현하는 과정에서 `이상적인 코드` 와 `마감일을 맞추기에는 충분한 수준의 코드` 사이의 타협
- 마감일을 위해 형편없는 코드를 허용해야 한다고 말하는 것은 아니지만 향후의 개선점을 염두에 두고 지금 당장은 간단하게 해결하는 방법역시 가치 있는 방법이다. 

###### 좋은 기술 부채와 나쁜 기술 부채
- 트레이드 오프 
  - 상황에 따라 필요한 좋은 부채가 있을 수 있다. 중요한 것은 선택 가능한 옵션들을 신중이 검토하여 이 부채를 짊어질 만한 가치가 있는지, 아니면 지금 당장 전체 비용을 지불하는 것이 좋을지를 결정하는 것이다. 

###### 기술 부채의 사분면
- 마틴 파울러가 정의
- X,Y축으로 평면 사분할하여 두가지 질문을 던짐
  -  `이 기술 부채가 합당한 이유를 통해 생성된 것인가?`
     - "예" 라면 기술 부채를 신중하게 결정한 것
     - "아니오"라면 이 부채는 무모한 것. 당장 처리하는 편이 낫다. 
  -  `이 기술 부채를 회피할 대안을 알고 있는가?`
     - 긍정적이 답이 가능하면 대안을 염두해두 상태에서 부채를 받아 들인것
     - 부정적인 답을 할 수 밖에 없다면 다른 대안은 존재 하지 않는 다는 것을 의미

- 질문에 결과에 따른 네가지 시나리오
  - 무분별함, 의도적 : 가장 위험한 부채. 이런 결정이 이루어졌다는 사실은 팀은 유연하지 않으며 피할 수 없는 실패를 향해 가고 있다는 경고.
  - 무분별함, 부주의함 : 경험부족으로 인한 부채. 이런 경우는 교육이 답이다. 개발자들이 배울 의지만 있다면 더는 생겨나지 않을 것이다. 
  - 분별있음, 부주의함 : 기존 사례를 충실히 따랐지만 그보다 너 나은 방법이 존재한다는 사실이 밝혀져 `이제는 이 작업을 어떻게 처리해야 하는지 알게 된` 경우
  - 분별있음, 의도적 : 가장 무난한 형태의 부채. 주로 `우선 출시 후 처리하는` 형태로 의사결정이 내려진 경우에 발생

###### 부채 상황하기

- 기술 부채는 스토리 포인트와 무관하지만 직접적인 인센티브가 없다 하더라도 반드시 상황해야 한다. 
- 가장 좋은 방법은 기술 부채 카드를 스토리에 부착하고 코드를 리팩토링하여 새로운 동작과 관련해 새로운 디자인을 구현하는 것

##### 디지털 스크럼 보드

- 디지털 스크럼 보드는 벽에 계속해서 매달아 두지 않으면 프로젝트에 대한 매우 중요한 정보를 보여 주지 못한다. 
- 업무가 잘 진행되고 있음을 공개함으로써 이해관계자들로부터 신뢰를 얻을 수 있다. 

##### 완료에 대한 정의
- 모든 프로젝트에는 완료에 대한 정의가 필요하다(DoD, Definition of Done)
- 만일 스토리가 진정으로 완료되었다면 여기에는 어떤 경고나 조건, 추가 필요사항이 없어야 한다. 
- 사용자 스토리를 완료하기 위해서는 반드시 다음의 사항을 준수해야 한다. 
  - 코드 실행의 성공 및 실패의 경우를 모두 커버할 수 있는 단위 테스트를 작성하며, 모든 테스트는 실패 없이 통과해야 한다. 
  - 모든 코드는 지속적 통합 서버에 전달되어(오류없이) 빌드 및 컴파일되어야 하며, 모든 테스트를 통과해야 한다.
  - 제품 소유자와 함게 수렴 가능한 조건들에 대한 제품의 동작을 검증한다. 
  - 해당 스토리에 참여하지 않은 개발자와 짝을 이루어 코드를 리뷰한다.
  - 의사소통에 필요한 만큼만 문서를 작성한다.
  - 무분별한 기술 부채를 해결한다. 
- 항목들을 바탕으로 자유롭게 규칙을 추가, 수정 혹은 제거해도 되지만, 이렇게 정의된 항목들에 대해서는 강력하게 규제해야 한다. 

#### 차트와 측정

- 스크럼 차트를 통해 스크럼 프로젝트의 현재 상태와 진행 과정의 궤적을 확인, 달성 가능한 향후의 성과를 예측할 수 있다. 
- 차트는 스크럼 보드에 항상 표시되어 있어야 한다.
- 이 차트는 팀의 역량을 공개적으로 측정하고 있음을 보여주기 위한 것이 아닐 뿐더러 관리자들을 위한 것도 아니다.
- 모두에게 공개하는 것이며 프로젝트의 문제점을 분석하기 위한 것임을 명확히 해야 한다. 
- 관련 노트에는 개별 달성 스토리 포인트 등과 같은 개인 평가는 언급되어서는 절대 안된다. 

##### 스토리 포인트

- 스토리 포인트는 매 스프린트에 비즈니스 가치를 부여하여 팀을 독력하기 위한 장치이다. 
- 스토리 포인트는 사용자 스토리가 표현하는 특정 기능을 구현하는 데 필요한 상대적인 노력의 정도를 의미한다. 
- 개발 과정을 완료하기 위해 필요한 노력의 정도를 모두 포함한다(분석, 디자인, 개발, 테스트, 배포등)
- 모든 스토리는 스프린트 기간 내에 완료할 수 있도록 충분히 작은 범위로 나뉘어야 하지만, 크기에 따라 다양하게 분류할 수 있다. 
- 가장 작은 크기의 스토리는 `1점 스토리`로 최소한의 노력으로 구현할 수 있는 스토리 이다. 
  - 중요하면서 흥미로운 사실은 팀 내부적으로만 의미를 갖는다는 점. 같은 스토리에 대해 팀마다 다른 포인트를 할당할 수 있다. 
- 스토리 포인트는 스토리를 완료하는 데 필요한 노력을 `시간`으로 측정하여 표현한 것은 아니다. 
  - 다만 대력적으로 그림 1-6에서 보여 주는 시간의 범위에 대응한다. 
- 범위가 큰 스토리일수록 완료하는데 드는 시간을 정확히 예측하기 힘들다.

##### 속도

- 스프린트를 연속해서 진행하다 보면 스토리 포인트를 달성하기 위해 평균적으로 소요되는 시간을 계산할 수 있게 된다. 
- 이것을 팀의 속도 라고 하며 두가지 방법으로 활용할 수 있다.
  - 다음 스프린트에 팀이 커밋해야 할 포인트의 한계치이다. 
  - 소프트웨어의 출시에 대한 문제를 분석하는 것 (속도가 감소할 경우 확인할 수 있고 대비할 수 있다.)

##### 스프린트 번다운 차트

- 번다운 차트는 일정한 양의 업무를 일정한 시간 내에 완료해야 할 때 유용하다. 
- 최적선과 진척선을 이용하여 프로젝트가 일정대로 진행되고 있는지를 확인할 수 있다. 

##### 기능 번업 차트 

- 기능들의 완료도를 표시한다. 
- 이 그래프의 가장 큰 장점은 그래프에 표시되지 않은 채 기능이 완료된 것처럼 눈속임을 할 수 없다는 점이다. 
- 어느 시점이 지난 이후로 업무 속도가 떨어지고 새기능이 추가되기 어렵고 느리다면 `코드가 변화를 수용하지 못하는 것이다. `
  - 이렇게 진행되는 프로젝트는 결함과 기술부채로 범벅이 되어 있는 경우가 대부분이다. 

#### 백로그 
- 백로그는 아직 시작되지 않은 대기 작업들의 목록이다. 
- 우선순위와 예상 난이도가 할당되어 있으며 이를 기준으로 정렬되어 있다. 

##### 제품 백로그
- 제품 백로그는 제품의 개발주기 동안 구현해야 할 기능들을 포함한다. 
- 각 아이템의 우선순위는 해당 기능을 구현했을 때 비즈니스에 제공할 수 있게 되는 가치를 최우선으로 고려하여 반영한다. (PO가 결정)
- 동일한 가치를 지녔다면 구현에 필요한 노력이 작은 기능을 우선한다. 예측이 쉽고 위험요소도 적다. 투자수익율이 높음
- 반드시 수정해야 하지만 아직 스프린트에 투입되지 않은 결함도 가지고 있다. 
- 누구나 볼 수 있어야 하고, 실제 상황을 반영하는 것 역시 매우 중요하다. 
 
##### 스프린트 백로그 
- 스프린트 백로그는 해당 스프린트 내에 완료해야 할 모든 사용자 스토리를 관리한다. 
- 팀은 스프린트를 시작할 때 팀의 현재 속도와 개발해야 할 각 사용자 스토리의 상대적인 크기를 기준으로 달성 가능한 양의 업무를 선택해 스프린트 백로그를 채운다. 
- 그 후 작은 태스크로 쪼개어 실제시간을 기준으로 예상 업무시간을 할당한다. 
- 스프린트 백로그와 예상 시간은 모두 개발팀의 몫이다. 
- 스프린트 백로그에 대해서는 오로지 개발팀이 책임을 지지만, 반드시 제품 백로그에서 우선순위에 따라 작업을 선택해야 한다.


### 스프린트 

- 스크럼 프로젝트의 반복되는 작업 주기를 스프린트라 한다
- 1주 ~ 4주 사이에 종료되어야 하며 대부분 2주 단위로 진행한다.
- 스프린트는 주로 인덱스 번호를 이용해 구분하며 제로부터 시작한다
  - 스프린트 제로는 대부분 스토리 포인트는 없지만 개발환경을 준비하고 주요 계획을 수립하는 것을 목적으로 한다. 

#### 출시 계획

- 고객과 PO가 출시일을 결정하고 출시 계획에 포함될 기능의 우선순위와 크기를 결정한다. 

##### 기능 예상
- 매우 큼, 큼, 중간, 작음 , 매우 작음 등으로 기능 구현에 필요한 노력을 표현한다.

##### 기능 우선순위

- 필수 : 반드시 제품의 출시에 포함되어야 할 기능
- 선호 : 시간적 여유가 있다면 출시에 포함되어야 할 기능
- 희망 : 이번 출시에 포함되지 않지만 고객이 구현되기 원하는 기능

#### 스프린트 계획

- 스프린트 계획 회의로 얻고자 하는 결과물은 예상 스토리 포인트 이다. 

##### 플래닝 포커

- 토론과 상대 예측에 가장 일반적으로 사용되며 스토리의 상태적인 크기를 가장 빠르게 예상할 수 있는 방법이다. 
- 스크럼 마스터, PO, 전체 개발팀이 참여한다. 
- 제품 백로그에 나열된 사용자 스토리를 간략히 설명 후 모든 사람이 어느 정도의 스토리 포인트를 할당할 것인지를 투표한다. 
  - 여러사람이 제안한 스토리 포인트 사이의 근소한 차이가 발생하는 것을 피하기 위해 일반적으로 피보나치 수열을 약간 수정하여 사용한다. 
  - 경우에 따라서는 평균값에 크게 벗어나는 사람들도 있다. 이런 경우에는 평균값의 견해를 기준으로 다시 조정하도록 요청할 수 있다. 

##### 상대 예측

- 플래닝 포커의 반대 개념으로, 작업할 스토리의 개수가 많은 경우 투입해야 할 시간의 양을 예상하는 방법이다. 
  - 토론을 진행하는 대신 제품 백로그 맨위에 있는 두 개의 스토리를 가져와 둘 중 어느 것이 더 작은 것인지를 결정, 작은 것은 왼쪽, 큰것을 오른쪽에 둔다
  - 백로그에서 하나를 더 꺼내서 앞에서 구분한 스토리와 크기를 비교해서 적당한 위치에 놓는다. 이걸 반복
  - 크기에 따라 스토리가 분류했으면 팀은 가장 왼쪽의 스토리 그룹부터 오른쪽 방향으로 업무를 진행하며 피보나치 수열을 이용하여 스토리 포인트를 할당하낟. 
  - 예상할 스토리가 많거나 시간이 부족한 경우에는 상대적인 크기에 따라 대략적으로 예상하는 것이 더 나은 방법이다. 

#### 일일 스크럼

- 팀은 스크럼보드 앞에 말발굽 형태로 모여 각 구성원이 순서대로 팀 전체를 대상으로 자신의 상황을 공유한다. 
- 15분을 초과할 수 없다. 
- 집중하기 위해 아래의 세 가지 질문에 대해서만 답변한다.
  - 어제 진행한 업무는 무엇인가?
  - 오늘 진행할 업무는 무엇인가?
  - 현재 당면한 방해 요소는 무엇인가?

- 스크럼 보드를 참고하며 카드나 아바타를 옮겨도 되고 현상태를 유지해도 된다. 
- 이 회의에서 주의할 점은 대화가 주제에서 벗어나지 않도록 하는 것이다. 

#### 스프린트 데모 

- 스프린트 일정에서 가장 중요한 이벤트이다.
- 완료된 스토리가 실제 환경에서 동작하는 것을 보여 주기 위한 회의.
- 전체 개발팀이 참석해야 하며, 임원이나 영업팀 대표자 등 다른 관련자를 초대할 수 있다. 
- 이렇게 함으로써 모든 프로젝트가 반드시 갖추어야 할 개방성을 조성할 수 있다. 

- 참석자들의 질문도 받되 주제에서 벗어나거나 관련이 없는 사항들에 대해서는 주의를 기울여 답한다. 
- 제품 개선을 위한 제안은 제품 백로그에 추가되어 우선순위를 부여하고 일정을 수립할 수 있도록 한다. 
- 간혹 데모 과정에서 제안된 개선점이 가장 중요한 것처럼 보일 수도 있지만. 그런 제안들이 현실을 제대로 반영하고 있는 경우는 드물다. 
- 데모는 두려운 과정이 아니라 장려해야 할 과정이다.  뭔가를 보이기 위해 완료 조건을 교묘하게 회피하는 우를 범하지 않도록 조심해야 한다. 
- 데모 시작하기 전에 코드 변경을 금지할 시간을 정해 두는 것도 좋다. 데모 몇 분 전에 변경 사항을 적용하려는 충동을 자제할 수 있다. 

#### 스프린트 회고

- 작업 주기를 되돌아보고 전체적인 성공 여부에 대한 의견을 교환할 차례이다. 
- 스프린트 회고를 진행하는 동안 팀이 고려해야 할 질문은 다음과 같다. 
  - 지난 스프린트에서 우리가 잘했던 일은 무엇인가?
  - 지난 스프린트에서 우리가 개선해야 할 점은 무엇인가?
  - 앞으로 새로 시작해야 할 일은 무엇인가?
  - 앞으로 지양해야 할 일은 무엇인가?
  - 앞으로도 계속해야 할 일은 무엇인가?
  - 스프린트 기간에 예상하지 못했던 일이 발생한 적이 있었나?

- 우선 잘 진행됐다고 생각하는 일이 무엇인지 자세히 물어봄으로써 긍정적인 내용으로 회의를 시작한다. 
- 다음으로 개선해야 할 점에 대해서 팀 구성원들이 개별적으로 설명하도록 한다
  - 문제가 무엇이든지 간에 어떤 종류라도 좋으니 해결책을 찾는 것이 중요하다. 
  - 다른 누군가를 `비난`해서는 안되며 생산적이면서도 정중하게 `비평`에 임해야 한다.
- 이 회의의 목적은 과정과 제품의 개선에 있다. 

- 잘 진행됐던 사항들을 바탕으로 지속적으로 반복해야 할 행동들을 도출. 좋은습관을 만들도록 하자
- 마지막으로 미처 예상하지 못했던 일들을 정리해 보고 대처 방안을 도출해 본다.
- 이 회의의 산출물들은 지속적으로 행동에 옮겨야 한다. 

##### 스토리 포인트 삼각법 
- 진행된 스토리 중 예상보다 더 많이, 더 적게 노력이 투입된 스토리가 있을 수 있다. 
- 회고 회의 마지막에 예상과 달랐던 스토리에 대해 삼각법을 적용해 보면 크게 도움이 된다. 
- 스토리 예측의 정확도를 높일 수 있다?

#### 스크럼 일정표
- 책? 참조?

### 스크럼과 애자일의 문제점
- 애자일 프로세스는 실패로 치닫고 있는 프로젝트를 성공으로 이끌어 수익을 보장할 수 있는 마법 같은 해결책은 아니다. 
- 이 책은 개발자들에게 적응형 소프트웨어 솔루션을 만드는 방법을 설명한다.
  - 적응형 소프트웨어란 모든 소프트웨어가 당면하게 되는 일련의 변화에 탄력적으로 대응할 수 있음을 의미한다. 
- 애자일 프로세스는 이러한 변화를 수용하고 소프트웨어의 개발 과정에서 소비자가 기능을 변경하는 것을 허용할 수 있도록 변화를 계속해서 추구하는 것이 목적이다. 

#### 비적응형 코드 
- 적응력이 떨어지는 코드. 변화를 따르기가 쉽지 않다.

##### 경직성 
 
 ###### 추상화의 부재
 - 추상화는 상세한 내용은 숨기고 보다 간소화된 표현을 보여 주는 방법이다.
 - 소프트웨어에서는 이런 추상화가 핵심이다. 
 
 ###### 책임의 혼재
 - 모든 수준의 코드(메서드, 클래스 및 모듈)들이 잘 정의된 하나의 책임만을 수행하도록 구현해야 한다. 

##### 테스트 불가능
- 테스트가 불가능한 코드는 테스트가 되지 않았다고 볼 수 있다. 
- 테스트가 되지 않은 코드는 결함을 가지고 있을 수 있다. 

###### 스카이훅 vs 크레인
- 스카이훅 : 이전 사례를 참고하지 않고 뭔가를 설명하는 방법
- 크레인 : (어쩌면 어떤 명확한 공식을 수립할 수 있을 때까지) 설명이 가능한 사례

- 모든 스카이훅은 적절한 크레인으로 대체해야 한다. 
- 코드내의 스카이 훅 사례
  - 정적 메서드
  - 정적 클래스(싱글턴 객체 포함)
  - new 연산자를 이용한 객체 생성 코드
  - 확장 메서드
- 이런 요소들은 코드에 모의 객체 주입하는데 방해가 되므로 테스트를 어렵게 만든다. 이들은 스카이 훅이며 이런 요소들을 사용해서는 안 된다. 

- 적절한 크레인으로 대체하여 외부로 부터 손쉽게 주입되도록 할 수 있다.
  - 인터페이스
  - 의존성 주입
  - 제어의 역전
  - 팩토리 패턴

##### 지표 

- 소스 코드는 수년에 걸쳐 다양한 지표(metrics)에 사용되어 왔다. 
- 지표는 각각 소스 코드이 복잡도와 프로젝트 전체의 건전성을 의미 있는 수준으로 감소 시키기 위한 것이다. 
- 필요한 노력을 측정하는 것과 관련이 있지만 시스템 기능 수준과 개발자의 생산성을 측정하는 것과는 무관하다. 

###### 단위 테스트 커버리지 
- 단위테스트로 테스트 가능한 코드의 백분율을 측정하는 값이다. 
- 대부분 최소 80% 커버리지를 최소한 수용 가능한 조건으로 설정하고 있다. 
- 테스트 커버리지는 질적 측정과는 달리 테스트 양을 기준으로 측정한 것이므로 오해의 소지가 있다.
  - 올바른 테스트가 아니라 아무런 테스트나 작성해도 커버리지가 손쉽게 증가하는 경향이 있다. 
- 지속적 통합 서버는 커버리지 백분율이 미달되면 빌드에 실패한 것으로 처리되도록 설정되어 있어야 한다. 
  - 단위 테스트 없이 새로운 코드가 추가될 수 없으며, 만일 그런 일이 있다면 커버리지 비율이 줄어들게 된다는 것을 의미한다. 

  ###### 순환 복잡도 
  - 코드에 존재하는 경로의 숫자를 측정하는 것
  - 코드를 추가로 분기할 때마다 순환 복잡도가 증가하게 된다. 
  - 순환 복잡도가 증가하면 가지치기한 코드에 대한 단위 테스트 코드 커버리지를 확보하기 위해 필요한 노력 역시 증가한다. 
    - 그래서 가지치기를 할 때 순환 복잡도를 낮게 유지하여 추가로 테스트 코드를 작성하지 않도록 하는 것이 최선이다. 
  - 또한 통계적으로 가지치기가 많으면 많을수록 더 많은 결함을 내포하게 된다는 것을 의미한다. 

  ### 마치며

  - 이번 장에서는 스크럼 프로세스에 대해 소개했다. 
  - 이 책의 나머지 부분에서는 애자일 프로젝트를 개발자의 관점에서 소개할 것이다. 
  - 이 책의 나머지 부분은 본질적으로 적응력이 높으며, 변화를 쉽게 적용하고, 매 스트린트마다 비즈니스 가치를 달성하는 것에만 초점을 맞출 수 있도록 하는 코드 작성 조건과 가이드라인을 제시한다. 









