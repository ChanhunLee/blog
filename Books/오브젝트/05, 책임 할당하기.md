## 05. 책임 할당하기

### 01 책임 주도 설계를 향해

데이터 중심 설계에서의 두 가지 원칙

> - 데이터 보다 행동을 먼저 결정하라.
> - 협력이라는 문맥 안에서 책임을 결정하라.

- 데이터보다 행동을 먼저 결정하라
  - 객체에게 중요한 것은 외부에 제공하는 행동
  - 행동이란 곧 객체의 책임을 의미.
  - 책임중심 설계
    - `이 객체가 수행해야 하는 책임은 무엇인가`
    - ` 이 책임을 수행하는 데 필요한 데이터는 무엇인가`


- 협력이라는 문액 안에서 책임을 결정하라.
  - 객체에게 할당된 책임이 협력에 어울리지 않는다면 그 책임은 나쁜 것이다. 
  - 적합한 책임이란 메시지 수신자가 아니라 전송자에게 적합한 책임을 의미한다. 
    - 객체를 결정한 후 메시지를 선택하는 것이 아니라 메시지를 결정 후에 객체를 선택해야 한다. 
    - 메시지를 먼저 결정하면 송신자는 수신자에 대한 가정을 할 수 없어 깔끔하게 캡슐화가 이루어진다.


- 책임주도 설계 
  - 3장의 내용 다시 나열
    - 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
    - 시스템 책임을 더 작은 책임으로 분할한다
    - 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
    - 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다
    - 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 된다. 


### 02 책임 할당을 위한 GRASP 패턴

General Responsibility Assignment Software Pattern(일반적인 책임 할당을 위한 소프트웨어 패턴)

- 도메인 개념에서 출발하기
    - 책임을 할당할 때 가장먼저 고민해야 하는 유력한 후보는 도메인 개념이다. 
    - 중요한 것은 설계를 시작하는 것이지 도메인 개념들을 완벽하게 정리하는 것이 아니다.(빠르게 설계와 구현을 진행하라)
    - 올바른 도메인 모델이란 존재하지 않는다.

- 정보 전문가에게 책임을 할당하라
  - 첫 단계는 애플리케이션이 제공해야 하는 기능을 앱에 전달된 메시지로 간주 하고 이것을 책임질 첫번째 객체를 선택하는 것으로 설계를 시작
    - 메세지를 전송할 객체는 무엇을 원하는가?
    - 메시지를 수신할 적합한 객체는 누구인가?
  - 정보 전무가 패턴에 따르면 필요한 정보를 가장 많이 알고 있는 객체에게 책임을 할당해야 한다. 
    - 책임을 수행하는 객체가 정보를 알고 잇다고 해서 그정보를 저장하고 있을 필욘 없다. 
  - 스스로 처리할 수 없는 작업이 있다면 외부에 도움을 요청.
    - 이 요청이 외부로 전송해야 하는 새로운 메시지
  - 적용 
    - 이미지로 보여주자 

- 높은 응집도와 낮은 결합도
  - 설계는 트레이드오프 활동이라는 것을 기억
    - 올바른 책임 할당을 위해 Information Expert 패턴 이외의 다른 책임 할당 패턴들을 함께 고려. 
  - Screening이 직접 DiscountCondition과 협력한다면?
    - 기능적으로는 동일. 
    - LOW COUPLING(낮은 결합도) 관점에서 본다면?
      - Movie에 이미 DiscountCondition 목록 속성을 가지고 있어서 이미 결합되어 있음
      - Movie와 DiscountCondition가 협력하면 추가 결합이 없기 때문에 더 좋은 선택
    - HiGH COHESION(높은 응집도) 관점에서 본다면?
      - Screening의 책임은 예매인데 DiscountCondition과 협력하면 요금계산에 관련된 책임 일부를 맡게됨
      - Movie가 할인여부를 필요로 한다는 사실 역시 알고 있어야 함.
      - 요금 계산 방식이 변경될 경우 Screening 도 변경이 됨


- 창조자에게 객체 생성 책임을 할당하라. 
  > GRASP의 CREATOR(창조자 패턴)
  >- 객체 A를 생성할 때 아래 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당하라. 
  >    - B가 A객체를 포함하거나 참조한다.
  >    - B가 A객체를 기록한다.
  >    - B가 A객체를 긴밀하게 사용한다.
  >    - B가 A객체를 초기화 하는데 필요한 데이터를 가지고 있다.(이 경우 B는 A에 대한 정보 전문가)
  >  - 이미 결합돼 있는 객체에게 생성 책임을 할당하는 것은 설계의 전체적인 결합도에 영향을 미치지 않는다. 

  - Reservation을 잘 알고 있거나, 긴밀하게 사용하거나, 초기화에 필요한 데이터를 가지고 있는 객체는?
    - Screening을 CREATOR로 선택하는 것이 적절해 보인다.

### 03 구현을 통한 검증 
- Screening 구현
  - `예매하라` 메시지의 응답 메서드 -> Reserve -> Reservation 창조
  - 책임을 수행하는데 필요한 인스턴스 변수
    - 상영시간 
    - 순번  
    - 영화(Movie) > 가격을 계산하라는 메세지 전송
  - `가격을 계산하라` 메시지를 전송할 CalculateFee 메서드
  - Movie.CalculateMovieFee 를 선언
    - <U>Movie 내부구현을 고려치 않고 Screening의 의도로 메시지를 결정 -> Movie의 캡슐화</U>
- Movie 구현
  - CalculateMovieFee 를 구현
    - IsDiscountable, CalculateDiscountAmount을 통해 할인여부 판단 및 요금계산
  - 인스턴스 변수
    - 영화 정보
    - 할인금액(DiscountAmount)
    - 할인비율(DiscountPercent)
    - 영화종류(MovieType)
  - IsDiscountable 구현
    - <U> `할인여부를 판단하라` 메시지를 처리할 DiscountCondition.IsSatisfiedBy 를 구현 </U>
    - DiscountConditions를 순회하며 DiscountCondition.IsSatisfiedBy를 통해 할인여부 판단 
  - CalculateDiscountAmount 구현
    - MovieType에 따라 적절한 할인 메소드를 호출
- DiscountCondition 구현
  - 인스턴스변수
    - 요일(dayOfWeek)
    - 시작시간(StartTime)
    - 종료시간(endTime)
    - 상영순번(Sequence)
  - IsSatisfiedBy 구현
    - type값에 따라 적절한 메소드를 호출

- DiscountCondition개선하기
    - 가장 큰 문제는 변경에 취약한 클래스를 포함하고 있다는 것
    - 세가지 이유로 변경될 수 있다
        - 새로운 할인 조건추가
        - 순번 조건을 판단하는 로직 변경
        - 기간 조건을 판단하는 로직 변경
    - 하나 이상의 변경 이유를 가지기 때문에 응집도가 낮다. 
    - <u> 변경의 이유에 따라 클래스를 분리해야 한다</u>
    - 변경의 이유 파악하기
        - 인스턴스 변수가 초기화 되는 시점
            - 높은 응집도는 인스턴스를 생성할 때 모든 속성을 함께 초기화
            - 함께 초기화 되는 속성을 기준으로 코드를 분리 
        - 메서드들이 인스턴스 변수를 사용하는 방식
            - 메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 응집도가 낮다
            - 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다. 
- 타입 분리하기
  - SequenceCondition과 PeriodCondition 두개의 클래스로 분리
    - 각 클래스는 자신의 모든 인스턴스 변수를 함께 초기화할 수 있다. (응집도 향상)
  - Movie가 각 두개의 클래스와 협력해야 하는 문제 생김
- 다형성을 통해 분리하기
  - SequenceCondition과 PeriodCondition 은 동일한 `역할` 을 수행
  - 역할에 대해서만 결합되도록 의존성을 제한 -> 추상화(인터페이스나 추상클래스)
  - POLYMORPHISM(다형성) 패턴 
- 변경으로부터 보호가기
  - 새로운 할인 조건을 추가한다면?
    -  DiscountCondition 인터페이스를 실체화 하는 클래스를 추가 함으로써 할인조건의 종류 확장 가능
  - 변경을 캡슐화하도록 책을 할당하는 것을 GRASP에서는 PROTECTED VARIATIONS(변경 보호) 패턴이라 함.
- Movie 클래스 개선하기
  - 금액 할인 정책 영화와 비율 할인 정책 영화를 다형성패턴을 이용하여 분리
    - DiscountCondition -> 인터페이스로 정의
    - Movie -> 추상클래스로 정의
    - AmountDiscountMovie
    - PercentDiscountMovie
    - NoneDiscountMovie
  - 이미지 첨부
  - 데이터 중심의 설계는 정반대의 길을 걷는다. 결론은 책임 중심의 설계를 하라. 
- 변경과 유연성
  - 설계를 주도하는 것은 변경
  - 변경에 대비하는 두가지 방법
    - 코드를 이해하고 수정하기 쉽도록 단순하게 설계
    - 코드를 수정하지 않고도 변경을 수용할 수 있도록 유연하게 만드는 것
    - 첫번째가 더 좋은 방법이지만 변경이 반복되면 복잡성이 상승하더라도 유연성을 추가하는 것이 좋다. 
  - 예를 들어 영화의 할인정책을 실행중에 변경해야 한다면?
    - 현재는 할인정책을 상속으로 구현하고 있기때문에 새로운 인스턴스 생성 후 정보 복사를 해야함.
      - 동일한 영화지만 두개의 객체가 존재
  - 변경이 유연하게 만들기 -> 합성을 이용
    - 이미지 첨부
    - 정책만 바꾸면 된다. 
  
### 04 책임 주도 설계의 대안
>- 책임과 객체 사이에서 방황할 때 빠르게 목적한 기능을 수행하는 코드를 작성하라. 그리고 리펙토링 하라
>- 리펙토링은 겉으로 보이는 동작은 바꾸지 않은 채 내부 구조를 변경하는 것

- 메서드 응집도 
  - ReservationAgency에 포함된 로직들을 적절한 객체의 책임으로 분배하면 책임 주도 설계와 거의 유사한 결과를 얻을 수 있다. 
  - 긴 메서드는 다양한 측면에서 코드 유지보수에 부정적인 영향을 미친다. 
    - 코드를 전체적으로 이해하는데 시간이 오래 걸린다.
    - 변경이 필요할 때 수정해야 할 부분을 찾기 어렵다
    - 일부 로직만 수정하더라도 나머지 부분에서 버그가 발생할 확률이 높다
    - 로직의 일부만 재사용하는 것이 불가능하다. 
    - 코드 중복을 초래하기 쉽다. 
  - 이런 메소드를 `몬스터 메서드`라 부른다(마이클 패더스)
  - 객체의 책임을 분배할 때 가장 먼저 할 일은 응집도 있는 수준으로 분해하는 것.
    - 수정후 Reserve
      - checkDiscountable 
        - isDiscountable
          - isSatisfiedByPeriod
          - isSatisfiedBySequence
      - calculateFee
        - calculateDiscountFee
          - calculateAmountDiscountFee
          - calculatePercentDiscountFee
          - calculateNoneDiscountFee
      - createReservation
  - 응집도는 여전히 낮다
- 객체를 자율적으로 만들자 
  - 자신이 소유하고 있는 데이터를 자기 스스로 처리하도록 만드는 것
  - 메서드 안에서 어떤 클래스에 접근하는지를 파악 하라
    - isDiscountable, isSatisfiedByPeriod, isSatisfiedBySequence 메소드는 DiscountCondition의 데이터를 이용함으로 DiscountCondition로 이동
>- 책임주도 설계가 익숙하지 않다면 데이터 중심으로 구현 후 리펙터링 하라. 유사한 결과를 얻을 수 있다.

