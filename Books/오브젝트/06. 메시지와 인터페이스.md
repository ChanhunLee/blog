## 06. 메시지와 인터페이스 

### 01 협력과 메시지
- 클라이언트-서버 모델
  - 객체 사이의 협력관계를 설명하기 위해 사용되는 전통적인 메타포 
  - 객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 동시에 수행하는 것이 일반적
- 메시지와 메시지 전송
  - 메시지 : 유일한 의사 소통 수단
  - 메시지 전송(sending) or 메시지 패싱(passing) 
  - 메시지 전송자(sender), 메시지 수신자(receiver)
  - 메시지는 오퍼레이션명(operation name)과 인자(argument)로 구성
- 메시지와 메서드
  - 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 `메서드`
  - 객체사이의 메시지 전송은 컴파일 시점과 실행 시점의 의미가 달라질 수 있다. 전통적인 함수, 프로시저 호출과는 다르다. 
- 퍼블릭 인터페이스와 오퍼레이션
  - 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 `퍼블릭 인터페이스`라 한다
  - 프로그래밍 관점에서 퍼블릭 인터페이스에 포함된 메시지를 `오퍼레이션` 이라 부른다. 
    - 수행가능한 어떤 행동에 대한 추상화.
    - 내부 구현코드를 제외한 시그니쳐, 구현코드는 메서드
- 시그니처
  - 오퍼레이션(또는 메서드)의 이름과 파라미터 목록을 합쳐 시그니처(signature)
  - 오퍼레이션 관점에서 다형성이란 동일한 오퍼레이션 호출에 서로 다른 메서드들이 실행되는 것
  
### 02 인터페이스와 설계 품질
퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법
- 디미터 법칙
  - 협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙   
  - `낯선 자에게 말하지 말라`, `오직 인접한 이웃하고만 말하라`
    - 자바나 C#에서 오직 하나의 `도트(.)`만 사용하라 라는 말로 요약된다. 
  - 클래스가 특정한 조건을 만족하는 대상에게만 메시지를 전송
    - this 객체
    - 메서드의 매개변수
    - this의 속성
    - this의 속성인 컬렉션의 요소
    - 메서드 내에서 생선된 지역 객체
  - 부끄럼타는 코드(shy code) : 불필요한 어떤 것도 다른객체에게 보여주지 않으며 다른 객체의 의존하지 않는 코드
  - 디미터의 법칙을 위반하는 코드
    - `screening.getMovie().getDiscountConditions()`
    - `기차 충돌(train wreck)` 이라 불리며 내부구조에 대해 물어보고 반환받은 요소에 연쇄적으로 메시지를 전송 하는 형태
    - 내부 구현이 외부로 노출되고 내부에 강하게 결합됨
- 묻지 말고 시켜라
    - 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다. 
    - 객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다. 
    - 내부의 상태를 이용해 어떤 결정을 내리는 로직이 외부에 있다면, 책임져야 하는 행동이 객체외부로 누수된 것이다. 
- 의도를 드러내는 인터페이스 
    - 켄트 벡(Kent Beck)의 메서드 명명법
        1. 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓는 것 
            - isSatisfiedByPeriod, isSatisfiedBySequence
            - 메서드에 대해 제대로 커뮤니케이션 하지 못한다.(같은 작업을 한다는 것을 알기 어렵다)
            - 메서드 수준에서 캡슐화를 위반한다. (책임 수행방법을 드러내는 메서드는 방법이 바뀌면 이름도 바뀌어야 되서 변경에 취약)
        2. `어떻게`가 아니라 `무엇`을 하는지를 드러내는 것
            - 코드를 읽고 이해하기 쉽게 만들고 유연한 코드를 낳는다. 
            - isSatisfiedBy
    - 의도를 드러내는 선택자(Intention Revealing Selector) : 무엇을 하느냐에 따라 메서드의 이름을 짓는 패턴
    - 의도를 드러내는 인터페이스 : 구현과 관련된 모든 정보를 캡슐화 하고 협력과 관련된 의도만을 표현해야 한다는 것
- 함께 모으기
    - 위의 원칙을 위반하는 코드의 모습을 살펴보자
    - 디미터의 법칙을 위반하는 티켓 판매 도메인
        - `Theater`가 호출하는 코드 `audience.getBag().minusAmount(ticket.getFee());`
        - `Theater`는 `Audience`의 내부 구조에 대해서도 결합이 된다. 
        - 인터페이스와 구현의 분리 원칙을 위반한다. 
    - 묻지 말고 시켜라
        - `Audience.SetTicket`가 `bag`에게 원하는 일을 시키기 전에 내부 상태를 묻는다.(`bag.hasInvitation()`)
        - `Audience.SetTicket` 구현을 `Bag.SetTicket` 으로 옮기면 상태 판단을 `Bag`이 하게되고 묻지 말고 시켜라를 따른다. 
    - 인터페이스에 의도를 드러내자 
        - TicketSeller.setTicket-> sellTo(Audience audience);
        - Audience.setTicket-> buy(Ticket ticket);
        - Bag.setTicket-> hold(Ticket ticket);
        - 오퍼레이션은 클라이언트가 객체에게 무엇을 원하는지를 표현해야 한다. 클라이언트의 의도를 표현하는 이름을 가져야 한다. 

### 03 원칙의 함정
- 디미터의 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다. 
    - `IntStream.of(1,15,20,3,9).filter(x->x>10).distinct().count();`
        - 각 메서드는 동일한 클래스의 인스턴스를 반환한다. 디미터의 법칙을 위반하지 않는다. 
    - 디미터의 법칙은 결합도와 관련된 것이며 객체의 내부구조가 노출되는 경우로 한정한다. 
- 결합도와 응집도의 충돌
    - 묻지말고 시켜라와 디미터 법칙준수가 항상 긍정적인 결과로만 귀결되진 않는다. 
        - PeriodCondition에서 Screening의 내부 영화 정보를 가져와서 할인을 판단하기 때문에 캡슐화를 위반한 것으로 보일수 있다.
        - 영화정보를 알고있는 Screening 할인조건을 판단하게 하고 PeriodCondition에서 이것을 호출한다면 묻지말고 시켜라 스타일의 인터페이스를 얻을수 있다 
            - 하지만! 할인정보 판단이 Screening의 역할이 맞는가?
            - 객체의 응집도가 낮아지고 PeriodCondition과의 결합도가 높아진다.
    - 디미터 법칙의 위반 여부를 묻는 대상이 객체인지, 자료구조인지에 달려있다.
        - 객체는 법칙을 따르는 것이 좋지만 자료구조는 적용할 필요가 없다. 

### 04. 명령-쿼리 분리 원칙
 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침을 제공
> - 루틴(routine) : 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈
> - 루틴은 프로시저와 함수로 구분할 수 있다. 
> - 프로시저 : 정해진 절차에 따라 내부의 상태를 변경하는 루틴의 종류 
>    - 부수효과를 발생시키지만 반환값이 없다
> - 함수 : 절차에 따라 필요한 값을 계산해서 반환하는 루틴의 종류
>    - 반환값이 있지만 부수효과를 발생시킬 수 없다.
> - 명령과 쿼리 : 객체의 인터페이스 측면에서 프로시저와 함수를 부르는 또다른 이름
>   - 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
>   - 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다. 
 
- 반복 일정의 명령과 쿼리 분리하기 (예제는 책 참조)
    - 명령과 쿼리를 뒤섞으면 실행 결과를 예측하기가 어려워질 수 있다.
    - 반환값을 돌려주는 메서드는 쿼리이므로 부수효과가 없고 몇 번을 호출해도 영향이 없다.
    - 반면 반환 값을 가지지 않는 메서드는 모두 명령이므로 호출할 때는 부수효과에 주의해야 한다. 
- 명령-쿼리 분리와 참조 투명성
    - 명령, 쿼리를 분리함으로써 명령형 언어의 틀 안에서 참조 투명성(referential transparency)의 장점을 제한 적으로 나마 누릴 수 있다. 
    - 참조 투명성이란 `어떤 표현식 e가 있을때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성`
        - 동일한 입력에 대해 항상 동일한 값을 출력하는 특성
        - 불변성(immutability)
    - 참조 투명성의 두가지 장점 
        1. 모든 함수를 이미 알고 있는 하나의 결괏값으로 대체할 수 있기때문에 식을 쉽게 계산
        2. 모든 곳에서 함수의 결과값이 동일하기 때문에 식의 순서를 변경해도 결과는 달라지지 않는다. 
    - ※함수형 프로그래밍
- 책임에 초점을 맞춰라 
    - 책임 주도 설계 원칙에 따라 메시지가 객체를 결정하게 하라
    
